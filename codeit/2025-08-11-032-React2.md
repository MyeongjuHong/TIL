# 🗓️ 2025-08-11 TIL 32일차

## ✅ 오늘의 성취 (잘한 점)

- 오전에는 과제, 오후에는 강의. 잘 진행했다!
- 멘토링도 잘 참여 완

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

React에서 배열 데이터 다루기 (`map`, `sort`, `filter`)와 상태 관리

### 🔹 주요 개념 정리

- **mock 데이터**: 네트워크 응답을 흉내낸 데이터
- **map**: 배열의 각 요소를 JSX로 변환하여 렌더링
- **sort**: 정렬 기준(`order`)에 따라 아이템 재정렬
- **filter**: 특정 조건의 아이템만 남기고 필터링
- **상태 변경**: 부모 컴포넌트에서 상태 관리 후, 자식에게 props로 변경 함수 전달
- **key**: 배열 렌더링 시 고유 식별자 필수 (index 사용 지양)

### 🔹 예제 코드

```jsx
// 부모 컴포넌트에서 상태와 삭제 로직 관리
const handleDelete = (id) => {
  setItems(items.filter((item) => item.id !== id));
};

<ReviewList items={items} onDelete={handleDelete} />;

// 자식 컴포넌트에서 id 전달
function ListItem({ item, onDelete }) {
  return <button onClick={() => onDelete(item.id)}>Delete</button>;
}
```

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

# React 데이터 다루기

## VSC 기능

1. **자동완성 (ToolTip)**

   - 맨 오른쪽: 임포트할 패키지 경로 표시
   - 없으면 단어 자동완성

2. `oc` → `onClick` 속성 자동완성
3. `hc` → `handleClick` 함수명 자동완성
4. `Cmd + Shift + L` → 멀티커서 단어 선택
5. `Option` 키 → 멀티커서 생성
6. **변수/함수명 전체 변경**

   - 선언 위치로 이동 → 이름 선택 후 `F2` → 변경하면 모든 곳에 반영

7. **선언된 파일로 이동**

   - `Cmd + 클릭`

8. **코드 줄 단위 이동**

   - `Option + ↑ / ↓`

9. **코드 복사/취소**

   - `Option + Shift + ↑ / ↓`

---

## Mock 데이터

- 네트워크로 받아올 데이터를 흉내낸 데이터
- `src` 폴더 안에 `components` 폴더 생성 (재사용 UI 컴포넌트 저장)
- **예시 구조**

```
src/
 ├── App.js         // 전체 앱의 root 컴포넌트
 ├── index.js       // 진입점 (ReactDOM.render)
 ├── components/    // 재사용 가능한 UI 컴포넌트들
 ├── pages/         // 페이지 단위 컴포넌트 (SPA 라우팅 시)
 └── styles/        // 스타일 파일
```

- `import 객체명 from '경로'` 로 목데이터 가져오기
- `ReviewList` 의 `item` prop으로 데이터 전달

---

## 배열 핸들링

### 1. `map` – 아이템 렌더링

- 많은 데이터를 JSX로 렌더링할 때 **map에서 아이템 컴포넌트를 반환**

```jsx
function ListItem({ item }) {
  return (
    <div>
      <h1>{item.title}</h1>
      <div>{item.desc}</div>
    </div>
  );
}

function List({ items }) {
  return (
    <ul>
      {items.map((item) => (
        <li key={item.id}>
          <ListItem item={item} />
        </li>
      ))}
    </ul>
  );
}
```

---

### 2. `sort` – 아이템 정렬

```jsx
const [order, setOrder] = useState('createdAt');
const sortedItems = items.sort((a, b) => b[order] - a[order]);

const handleNewest = () => setOrder('createdAt');
const handleBest = () => setOrder('rating');

<button onClick={handleNewest}>최신순</button>
<button onClick={handleBest}>평점순</button>
<List items={sortedItems} />
```

- `b-a` → 내림차순
- 대괄호 표기법으로 정렬 기준 동적 변경 가능

---

### 3. `filter` – 아이템 삭제

**부모 컴포넌트**

```jsx
const handleDelete = (id) => {
  const remainItems = items.filter((item) => item.id !== id);
  setItems(remainItems);
};

<ReviewList items={items} onDelete={handleDelete} />;
```

**ReviewList 컴포넌트**

```jsx
function ReviewList({ items, onDelete }) {
  return (
    <>
      {items.map((item) => (
        <ListItem key={item.id} item={item} onDelete={onDelete} />
      ))}
    </>
  );
}
```

**ListItem 컴포넌트**

```jsx
function ListItem({ item, onDelete }) {
  const handleDeleteClick = () => onDelete(item.id);
  return <button onClick={handleDeleteClick}>Delete</button>;
}
```

**왜 부모에 handleDelete를 두는가?**

- **데이터 흐름**: React는 보통 데이터가 부모 → 자식으로 흐름
- **상태 업데이트 권한**: `setItems`는 상태가 있는 부모에 있어야 함
- **재사용성**: 여러 자식에서 같은 상태를 수정하면 혼란, 부모에서 일괄 관리

**왜 자식에서 id를 전달하는가?**

- 자식은 자신이 가진 `id`를 알고 있음
- 삭제할 대상을 부모에게 알려야 부모 상태에서 제거 가능

---

### 4. `key`

- 배열 렌더링 시 `key` 필수
- 배열 인덱스(`index`)는 **고유 값이 아님 → 사용 지양**
- 순서 바뀌면 잘못된 위치에 렌더링될 수 있음
- **권장**: `item.id` 같이 데이터의 고유한 값 사용
- `key`는 React가 변경 사항을 효율적으로 감지하도록 돕는 역할

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- TIL 또 하루 뒤에 제출..ㅠ
- 생각보다 속도가 지지부진하다.. 어떡해!!!!!!!!!!!

---

## 🚀 내일의 계획

- React2 강의 끝내기
- TIL 바로바로!!

---
