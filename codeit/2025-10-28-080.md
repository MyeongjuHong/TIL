# 🗓️ 20yy-mm-dd TIL n일차

## ✅ 오늘의 진행 (완료한 작업)

- \[오늘 한 작업 요약]

---

## 🛠️ 작업 상세

### 🔹 구현/수정한 기능

- 예

### 🔹 발생한 이슈 & 해결 과정

- 예

### 🔹 미해결/보류된 이슈

- 예

---

## 📓 작업 메모 (코드/아이디어/레퍼런스)

<details>
<summary style="font-size: 22px;">📝 메모장</summary>

### **Enum 검증 중복 개선**

현재:

```js
if (grade && !Object.values(Grade).includes(grade)) throw errors.invalidQuery();
if (genre && !Object.values(Genre).includes(genre)) throw errors.invalidQuery();
```

→ 깔끔하지만 중복돼서, 나중에 Enum이 많아지면 비효율적일 수 있습니다.
💡 **제안:**

```js
const isValidEnum = (value, enumType) =>
  !value || Object.values(enumType).includes(value);
if (!isValidEnum(grade, Grade) || !isValidEnum(genre, Genre))
  throw errors.invalidQuery();
```

#### **utils로 모든 enum 검증 함수 빼놓기**

```js
// utils/enumValidator.js
import errors from "../errors.js";
import { Grade, Genre, OtherEnum1, OtherEnum2 } from "../constants/enums.js";

const ENUM_MAP = {
  grade: Grade,
  genre: Genre,
  otherEnum1: OtherEnum1,
  otherEnum2: OtherEnum2,
};

/**
 * 키-값 객체를 받아, 해당 키에 맞는 Enum 검증
 * @param {string[]} keys - 검증할 Enum 키
 * @param {object} values - 실제 값 { grade, genre, ... }
 */
export function validateEnums(keys, values) {
  for (const key of keys) {
    const enumType = ENUM_MAP[key];
    if (!enumType) continue;
    const value = values[key];
    if (value && !Object.values(enumType).includes(value)) {
      throw errors.invalidQuery();
    }
  }
}
```

---

### **gradeCounts 초기화 코드 개선**

```js
const gradeCounts = {
  COMMON: 0,
  RARE: 0,
  SUPER_RARE: 0,
  LEGENDARY: 0,
};
groupGrades.forEach((grade) => (gradeCounts[grade.grade] = grade._count.grade));
```

→ 괜찮지만, Prisma에서 없는 등급은 결과에 안 나올 수 있어서
**자동으로 gradeCounts를 채우게 하면** 더 깔끔해요 👇

```js
const gradeCounts = Object.fromEntries(Object.values(Grade).map((g) => [g, 0]));

groupGrades.forEach(({ grade, _count }) => {
  gradeCounts[grade] = _count.grade;
});
```

---

### **select 필드 명세 관리**

```js
select: {
  id: true,
  creator_id: true,
  name: true,
  grade: true,
  genre: true,
  price: true,
  total_count: true,
  image_url: true,
  createdAt: true,
  updatedAt: true,
},
```

→ 이런 필드셋은 여러 API에서 반복될 수 있으므로,
**`prismaSelect.cardList`** 같은 상수로 별도 파일에 분리해두면 유지보수가 좋아요.

---

### 1️⃣ `forEach`와 배열 자체는 안 바뀜

```js
groupGrades.forEach(({ grade, _count }) => {
  gradeCounts[grade] = _count.grade;
});
```

- `groupGrades`는 **배열 자체**입니다.
- `forEach` 안에서 **배열 요소를 바꾸지 않았어요** → 배열(`groupGrades`) 구조나 내용은 그대로 유지됨
- `console.log(groupGrades)`를 찍어도 여전히 `[ { _count: { grade: 1 }, grade: 'RARE' } ]`

> 즉, `forEach`는 단순히 배열을 순회할 뿐, 배열 외부 객체(`gradeCounts`)를 바꾸는 작업은 **배열 요소를 수정하지 않는 한 배열에는 영향 없음**


---

### 2️⃣ `gradeCounts`는 바뀌는 이유

- `gradeCounts`는 **별도의 객체**입니다:

```js
const gradeCounts = {
  COMMON: 0,
  RARE: 0,
  SUPER_RARE: 0,
  LEGENDARY: 0,
};
```

- `forEach` 안에서 이렇게 했죠:

```js
gradeCounts[grade] = _count.grade;
```

- 여기서 `gradeCounts[grade]`를 **직접 수정** → 객체 값이 바뀜
- 배열 `groupGrades`와는 **다른 객체**라서 이 작업이 배열에 영향 미치지 않음

---

</details>

---

## 🧠 오늘의 회고 (아쉬움 & 배운 점)

- 예

---

## 🚀 내일의 계획

- 예
