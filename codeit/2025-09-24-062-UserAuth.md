# 🗓️ 2025-09-24 TIL 62일차

## ✅ 오늘의 성취 (잘한 점)

- auth login, signup 완료~ 프론트는 fetch client 사용 전까진 코드 한줄이면 되니 쉽다ㅋㅋ 백이 문제다 백이
- 오랜만에 TIL 자세한 정리~!

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

### 🔹 주요 개념 정리

### 🔹 예제 코드

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

# 인증

### 회원가입 프로세스

1. 클라이언트 내 입력 정보 유효성 검사
2. 인증 정보를 `POST` 요청으로 서버 전송
3. 서버에서 body 데이터 유효성 검사
4. DB에 저장

#### 상태 코드

| 상황                                | 대표 상태코드                 | 비고                                               |
| ----------------------------------- | ----------------------------- | -------------------------------------------------- |
| 회원가입 성공                       | **201 Created**               | 일부는 **200 OK** 사용                             |
| 요청 본문 오류 / 필드 누락          | **400 Bad Request**           | 이메일 형식 오류, 필수 정보 누락 시 사용           |
| 이메일 / 아이디 중복                | **409 Conflict**              | 일부는 **400 Bad Request**로 처리하기도 함         |
| 형식 오류 (비밀번호 요구 불충족 등) | **422 Unprocessable Entity**  | 요청 구문은 맞지만 의미적으로 처리 불가            |
| 가입 금지 (정책 위반, 차단된 IP)    | **403 Forbidden**             | 인증 문제와는 별개로, 정책상 허용되지 않을 때 사용 |
| 서버 오류                           | **500 Internal Server Error** | 표준적으로 사용됨                                  |

### 로그인 프로세스

1. 클라이언트 내 입력 정보 유효성 검사
2. 서버에서 `body`에서 이메일과 기존 회원 정보 비교
3. 이메일 확인 시 비밀번호 비교
4. 유저에게 로그인 성공에 대한 `인증서` 제공

#### 로그인 인증서

| 인증 방식 | 인증서 형태  | 전달 방식             |
| --------- | ------------ | --------------------- |
| 세션 인증 | 세션 ID      | 쿠키로 전달           |
| 토큰 인증 | Access Token | Body 또는 쿠키로 전달 |

#### 상태 코드

좋아요! 요청하신 로그인 성공/실패 상황을 **표 형태**로 깔끔하게 정리하면 아래와 같습니다.

| 상황                                    | 대표 상태코드                 | 비고                                         |
| --------------------------------------- | ----------------------------- | -------------------------------------------- |
| 로그인 성공 - 일반                      | **200 OK**                    | 일반적인 로그인 성공                         |
| 로그인 성공 - 토큰/세션 새로 생성       | **201 Created**               | 일부 API에서 새 세션/토큰 생성 시 사용       |
| 로그인 성공 - 본문 없음                 | **204 No Content**            | 성공했지만 응답 본문이 없는 경우 (드문 경우) |
| 요청 형식 오류 / 필수 필드 누락         | **400 Bad Request**           | 이메일/비밀번호 필드 누락 등                 |
| 잘못된 자격 증명                        | **401 Unauthorized**          | 이메일 또는 비밀번호가 유효하지 않을 때      |
| 접근 금지                               | **403 Forbidden**             | 계정 잠김, 접근 권한 없음 등                 |
| 사용자 존재하지 않음                    | **404 Not Found**             | 일부 API에서 존재하지 않는 사용자 요청 시    |
| 의미적으로 처리 불가 (비활성화 계정 등) | **422 Unprocessable Entity**  | 요청은 유효하지만 로그인 불가                |
| 로그인 시도 초과                        | **429 Too Many Requests**     | 너무 많은 로그인 시도로 제한됨               |
| 서버 오류                               | **500 Internal Server Error** | 서버 문제로 로그인 처리 실패                 |

> 무엇으로 인증하는가? `세션`  vs  `토큰`  
> 어떤 방식으로 전달하는가? `쿠키`  vs  `헤더`

## 쿠키 전달 인증 (HOW)

로그인 성공시 서버에서 인증서를 `쿠키`를 통해 응답해주는 인증 방식

- 브라우저에 저장된 쿠키는 별도 설정 없이 항상 서버 요청시 자동 전달
- 동일한 도메인에서만 쿠키 허용
- 로그인 성공 시 서버가 생성한 인증서를 응답 쿠키에 Set-Cookie 적용
  로그인 후 유효성 검사가 끝나면 서버가 set-cookie를 브라우저에 전달
  브라우저가 api 호출할 때 세팅된 쿠키가 함께 전달돼 서버가 사용자 특정

## Authorization 헤더 전달 인증 (HOW)

## 세션 기반 인증 (WHAT)

## 토큰 기반 인증 (WHAT)

## 1️⃣ 토큰 기반 인증에서 쿠키 사용 시나리오

1. **HttpOnly 쿠키에 토큰 저장**

   * 클라이언트 JS에서 직접 접근할 수 없는 쿠키 (`HttpOnly`)에 JWT를 저장
   * 서버가 요청을 받을 때 **자동으로 쿠키를 읽어서 인증**
   * 장점: XSS 공격으로부터 안전
   * 단점: CSRF 공격 가능 → 서버에서 CSRF 토큰 추가 필요

   ```http
   GET /api/user
   Cookie: token=<JWT>
   ```

2. **SPA + Refresh Token 관리**

   * **Access Token**은 `Authorization` 헤더에 넣어 쓰고
   * **Refresh Token**은 HttpOnly 쿠키로 저장 → 안전하게 토큰 갱신 가능
   * 이 방식이 최근 실무에서 가장 많이 씀

---

## 2️⃣ 토큰 기반 인증에서 헤더 사용 시나리오

* 클라이언트 JS에서 직접 토큰을 가져와 `Authorization: Bearer <token>` 헤더에 넣어 요청
* 장점: CSRF 걱정 없음 (헤더는 자동 전송되지 않음)
* 단점: XSS 공격에 노출되면 토큰 탈취 위험

---

## 3️⃣ 요약

| 저장/전달 방식               | 설명                                             | 장점               | 단점         |
| ---------------------- | ---------------------------------------------- | ---------------- | ---------- |
| **헤더 (Authorization)** | 클라이언트가 직접 토큰 넣어서 요청                            | CSRF 안전          | XSS 취약     |
| **쿠키 (HttpOnly)**      | 서버가 쿠키 읽어 인증                                   | XSS 안전           | CSRF 대비 필요 |
| **조합**                 | Access Token → 헤더, Refresh Token → HttpOnly 쿠키 | 보안 ↑, SPA/모바일 대응 | 구현 조금 복잡   |

---

즉, **토큰 기반 인증이라고 해서 반드시 헤더만 쓰는 건 아니고, 쿠키를 함께 쓰는 경우도 많음**.
실무에서는 보통 이렇게 쓰죠:

* **Access Token**: JS에서 헤더에 넣어서 요청 (빠른 인증)
* **Refresh Token**: HttpOnly 쿠키 → 안전하게 갱신


## 기본 인증 (레거시)

# 인가

##

authorization 헤더
유효성 검사 끝나면 body에 인증서 전달
보통 local storage에 저장
fetch 시에 header에 인증서 포함해 요청

# 사용자 기능

## 🔗 공통점

1. **기본 구조 동일**

   - `baseURL + url` 형태로 API 요청
   - `defaultOptions` → `options`와 병합 (`headers`는 깊은 병합)
   - 응답이 `!response.ok`이면 `throw new Error` 발생
   - 정상 응답은 `response.json()` 반환

2. **에러 처리 방식**

   - 모두 `response.ok` 체크 → 아니면 `Error` 던짐
   - `tokenFetch`만 **추가적인 401 처리 로직** 존재

---

## 🔎 함수별 차이점

### 1. `defaultFetch`

- **용도**: 인증 필요 없는 일반 요청
- **기본 옵션**

  ```js
  cache: "force-cache"; // Next.js 기본 캐싱 (정적)
  ```

- 즉, **캐싱이 활성화**되어 SSR/SSG 상황에서 자주 쓰기 적합

> 인증 필요 없고, 바뀌지 않는 공용 데이터 가져올 때

- **예시**

  - 서비스 소개 페이지의 "카테고리 목록", "FAQ", "공지사항"
  - 오픈된 상품 리스트 (로그인 안 해도 볼 수 있는 경우)
  - "회사 정보" API

```js
// 예: 카테고리 불러오기 (SSG 캐싱 OK)
const categories = await defaultFetch("/categories");
```

- ✅ 장점: 캐시(`force-cache`) → 요청 부하 줄이고 빠른 응답
- ❌ 단점: 데이터가 바뀌어도 즉시 반영 안 됨 (재배포/캐시 갱신 필요)

---

### 2. `cookieFetch`

- **용도**: 쿠키 기반 인증이 필요한 요청
- **기본 옵션**

  ```js
  credentials: 'include', // 브라우저 쿠키 포함
  cache: 'no-store',      // 매번 서버로부터 fresh 데이터 가져옴
  ```

- SSR 환경에서도 매번 **재검증 필수 데이터** 요청에 사용 (예: 로그인 상태 확인 API)

> **SSR**에서 로그인 사용자 정보를 항상 최신으로 불러와야 할 때

- **예시**

  - `getServerSideProps` 또는 **App Router의 서버 컴포넌트**에서 로그인 사용자 정보 확인
  - "마이페이지" 접근 시 사용자 프로필
  - "장바구니" 같은 로그인 상태 기반 데이터

```js
// 예: 서버 컴포넌트에서 로그인 유저 정보 가져오기
const user = await cookieFetch("/users/me");
```

- ✅ 장점: 쿠키(`credentials: include`) 기반 인증, 자동으로 세션/CSRF 보호 가능
- ❌ 단점: `no-store`라서 매번 서버에서 확인해야 함 → 트래픽 많음

---

### 3. `tokenFetch`

- **용도**: 헤더에 JWT 같은 토큰을 넣어 인증하는 요청
- **기본 옵션**

  ```js
  headers: {
    Authorization: `Bearer ${token}`, // localStorage에서 꺼내온 토큰
  },
  next: { revalidate: 60 } // ISR: 60초마다 재검증
  ```

- **추가 로직**

  - 401 Unauthorized 응답이 오면:

    1. `refreshToken` 요청 시도 (`/auth/refresh`)
    2. 새 토큰 발급 → localStorage 갱신 → 원래 요청 재시도
    3. 리프레시 실패 시: `localStorage` 토큰 삭제 + `/login`으로 리다이렉트

- 즉, **자동 토큰 갱신 로직**을 갖고 있음 → 나머지 fetch들과 가장 큰 차이점

> **JWT 기반 인증**이 필요한 API 요청 (대부분의 "로그인 후 기능")

- **예시**

  - 로그인 후 **게시글 작성/수정/삭제**
  - 유저 전용 API (예: "내 주문 내역", "찜 목록")
  - 토큰 만료 시 자동 갱신 필요 → UX 개선

```js
// 예: 로그인 후 주문 내역 가져오기
const orders = await tokenFetch("/orders");
```

- ✅ 장점: 401 에러 시 자동 리프레시 토큰 요청 → 사용자는 로그아웃 안 당하고 매끄럽게 사용 가능
- ❌ 단점: SSR 환경에서는 `localStorage` 접근 불가 → **클라이언트 전용**

---

### 4. `dynamicFetch`

- **용도**: 클라이언트에서만 실행되는 동적 데이터 요청
- **기본 옵션**

  ```js
  cache: "no-store"; // 캐싱 금지, 항상 fresh 데이터
  ```

- SSR에선 캐싱하지 않고, 클라이언트 환경에서 데이터 실시간으로 불러올 때 유용
  (예: 실시간 댓글 목록, 알림 등)

> 로그인 여부 상관없이 **실시간성 있는 데이터** 요청 (클라이언트 전용)

- **예시**

  - 실시간 댓글 목록 (캐싱하면 안 됨)
  - "알림(Notification)" 리스트
  - "현재 접속자 수" 같은 라이브 데이터

```js
// 예: 새 댓글 불러오기 (CSR 전용)
const comments = await dynamicFetch(`/posts/${postId}/comments`);
```

- ✅ 장점: `no-store`라 항상 최신 데이터 보장
- ❌ 단점: 캐싱이 아예 없으니 호출 비용 큼 → polling/websocket 같은 대체 수단 필요할 수 있음

---

## 📊 한눈에 비교 표

| 함수명           | 인증 방식                 | 캐싱 전략                 | 특징                               |
| ---------------- | ------------------------- | ------------------------- | ---------------------------------- |
| **defaultFetch** | 없음                      | `force-cache` (기본 캐시) | 정적/공용 데이터 요청용            |
| **cookieFetch**  | 쿠키 (`credentials`)      | `no-store`                | SSR + 쿠키 인증 (세션 기반 로그인) |
| **tokenFetch**   | 토큰 (헤더 Authorization) | `next.revalidate: 60`     | 자동 토큰 리프레시 로직 포함       |
| **dynamicFetch** | 없음                      | `no-store`                | 항상 fresh 데이터, 클라이언트 전용 |

---

👉 요약하면,

- **defaultFetch**: 캐시 가능한 공용 API (비로그인 데이터)
- **cookieFetch**: 쿠키 기반 인증 (SSR/CSR 공통)
- **tokenFetch**: 토큰 기반 인증 + 자동 리프레시
- **dynamicFetch**: 항상 실시간 요청 (클라이언트 전용)

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 오랜만에 코드잇 정리할 때처럼 자세히 정리하려고 했다가 하마터면 실습 시간 통으로 날릴 뻔 했다
- 여기는 그냥 실습하다가 궁금한 부분을 정리하는게 더 빠르고 효율적일 것 같다

---

## 🚀 내일의 계획

- 예
- 예

---
