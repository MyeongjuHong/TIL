# 🗓️ yyyy-mm-dd TIL n일차

## ✅ 오늘의 성취 (잘한 점)

- 코테 숙제 완~~
- 비동기 공부도 하긴 했지..ㅎ

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

- 비동기 자바스크립트의 동작 원리
- 콜백 함수와 비동기 함수
- 콜백 헬 문제와 해결 방안
- useEffect의 비동기적 특성과 현재 프론트엔드 트렌드

### 🔹 주요 개념 정리

- 자바스크립트에서 오래 걸리는 작업이 있는 경우, 이후 작업을 먼저 실행하고 나중에 다시 돌아와 마무리하는 방식이 **비동기 실행 방식**임.
- 웹 환경에서 리퀘스트 전송, 사용자 상호작용 대기 등 비동기 프로그래밍이 자주 사용됨.
- 비동기 프로그래밍에서 반드시 이해해야 할 개념: **콜백(callback)**, **프로미스(Promise)**.
- `파라미터(parameter)`는 함수에 전달받은 값을 내부로 넘기는 변수, `아규먼트(argument)`는 실제로 전달되는 값.

### 🔹 예제 코드

```js
setTimeout(() => {
  console.log("비동기 실행 예시");
}, 1000);

function greet(name, callback) {
  console.log("안녕하세요 " + name);
  callback();
}

greet("이름", () => {
  console.log("콜백 함수 실행됨");
});
```

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

- 비동기 JS는 오래 기다려야 하는 작업이 있을 경우, 다음 작업을 먼저 실행한 뒤 처리 중이던 작업으로 다시 돌아와 마무리하는 방식임.
- 웹에서는 리퀘스트 전송이나 사용자 상호작용 대기처럼 비동기 처리가 필요한 경우가 많기 때문에 자주 사용됨.
- 비동기 프로그래밍을 위해 반드시 알아야 하는 개념은 **콜백(callback)** 과 **프로미스(Promise)**.
- `파라미터`는 함수 내부로 전달되는 변수이며, `아규먼트`는 실제로 함수에 전달되는 값임.

#### 📌 콜백과 비동기 실행

- 콜백은 함수의 아규먼트로 전달되는 함수. 콜백 함수는 괄호 없이 함수 자체를 전달함. 괄호를 붙이면 **함수 호출**로 간주되어 리턴값이 전달됨.
- 함수의 인자를 내부 콜백 함수의 인자로 넣을 수 있음.
- 간단한 콜백에는 화살표 함수 사용 가능.
- 문자열은 불변이기 때문에 `el.toUpperCase()`는 반환 값을 변수에 담아야 하며, 그렇지 않으면 무시됨. 예: `console.log(el.toUpperCase());`

#### 📌 비동기 함수와 콜백

- **비동기 함수(Asynchronous Function)** 는 끝까지 실행하지 않고 중간에 다른 작업을 처리한 후 다시 돌아와 마무리함.
- 실행 순서 예:

  ```
  일반함수;
  비동기함수(콜백함수);
  일반함수;
  ```

  1. 일반 함수 실행
  2. 비동기 함수는 JS 엔진이 Web API (브라우저 또는 Node.js의 타이머 API) 영역에 넘김
  3. Web API는 타이머 시작 후 콜백 함수를 대기 상태로 둠
  4. 콜백 함수는 지정 시간이 지난 후 이벤트 큐로 이동하여 실행됨

- `setTimeout(함수, 0)`은 즉시 실행처럼 보여도 실제로는 모든 동기 코드가 실행된 뒤 실행됨
- 비동기 함수는 병렬 처리되지만, 콜백 함수 실행은 동기적으로 이루어짐

#### 📌 다양한 비동기 함수

- `setInterval(콜백, 간격)`은 무한 반복이며, `clearInterval`로 종료 가능
- `addEventListener`도 비동기 함수. 상호작용이 있을 때까지 대기함.
- **React의 useEffect도 비동기 함수**. 컴포넌트가 화면에 렌더링된 후 콜백 실행.
- 그러나 최근에는 React Query, Server Component, custom hook 등으로 대체되는 추세임.

##### ✅ useEffect 사용이 적절한 예

| 상황                 | 예시                              |
| -------------------- | --------------------------------- |
| 외부 라이브러리 연동 | 지도 API, chart.js, video.js 등   |
| 브라우저 이벤트 등록 | `window.addEventListener(...)`    |
| 수동 DOM 조작        | `ref.current.scrollIntoView()` 등 |
| 로깅 및 디버깅       | 조건 발생 시 콘솔 출력 등         |

##### ✅ 과거 vs 현재

| 과거 (2020 이전)           | 현재 (2025)                                                                         |
| -------------------------- | ----------------------------------------------------------------------------------- |
| useEffect로 모든 것 해결   | 데이터는 서버에서 가져오고 클라이언트에서는 `use`, React Query 등으로 간결하게 처리 |
| 복잡한 로딩/에러 상태 관리 | 필요한 경우에만 useEffect 사용                                                      |
| 사이드 이펙트 남용         | 필요한 경우만 사용하도록 제한                                                       |

- `get(‘/주소’, 콜백)` 패턴은 express에서 사용됨. 주소로 GET 요청이 들어오면 해당 콜백 함수가 실행됨.

#### 📌 콜백의 한계

- 여러 비동기 작업을 순차적으로 처리하면 콜백이 중첩되어 코드 가독성과 유지보수가 어려움
- 이를 **콜백 헬(callback hell)** 이라고 하며,

  - 이해도 낮음
  - 디버깅 어려움
  - 테스트 어려움

- 이를 해결하기 위해 **Promise 문법**이 도입됨

#### 📌 용어 정리

- **파싱(Parsing)**: 응답(Response)에서 원하는 데이터를 추출하여 JS에서 사용하기 편한 형태로 가공하는 작업

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 밀리다..!!
- 너무 느려 내가!!!

---

## 🚀 내일의 계획

- 비동기 JS를 끝내야만.
- JS 리퀘스트도 끝내야만..!!

---
