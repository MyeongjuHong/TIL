# 🗓️ 2025-08-18 TIL 35일차

## ✅ 오늘의 성취 (잘한 점)

- 라우터 완!! 설치도 없고 간단해서 빨리 들을 수 있었다
- 기존에 해봤던 개념이라 실습도 괜찮았다. 동적 파라미터쪽만 좀 익숙해지면 될 듯?

---

## 📚 오늘의 학습 (배운 점)

## 🔹 핵심 주제

리액트 라우터(react-router-dom)를 활용해 **싱글 페이지 애플리케이션(SPA)** 에서 경로 기반 페이지 전환과 레이아웃 구성을 구현하는 방법.

---

## 🔹 주요 개념 정리

- **라우터 기본**: `BrowserRouter`로 감싸고, `Routes` + `Route`로 경로와 컴포넌트 매핑
- **Link / NavLink**: a 태그 대신 사용, SPA 방식 페이지 이동. `NavLink`는 활성화 여부에 따라 스타일 지정 가능
- **중첩 라우트 & Outlet**: 부모 컴포넌트 레이아웃 유지 + 하위 라우트 교체 렌더링
- **동적 경로(useParams)**: `:id` 같은 URL 세그먼트를 변수로 받아와 API 호출 등에 활용
- **쿼리 스트링(useSearchParams)**: URL 뒤 `?key=value` 형태 파라미터를 상태처럼 다룸
- **페이지 이동 방식**

  - `<Link>`: 사용자 클릭
  - `<Navigate>`: 조건 충족 시 즉시 리다이렉트
  - `useNavigate()`: 이벤트/코드 실행 후 이동

- **예외 처리**: `*` path로 404 페이지 처리
- **SEO/title 관리**: `react-helmet` 사용
- **렌더링 방식**

  - CSR: 클라이언트에서 HTML 생성 (React Router)
  - SSR: 서버에서 HTML 생성 후 전달 (Next.js)
  - SSG: 빌드 시 HTML 미리 생성 (Gatsby)

---

## 🔹 예제 코드

```jsx
// index.js
import {
  BrowserRouter,
  Routes,
  Route,
  Link,
  NavLink,
  Outlet,
  useParams,
  useNavigate,
} from "react-router-dom";

// 라우터 구조
function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<HomePage />} />

        <Route path="posts" element={<PostLayout />}>
          <Route index element={<PostListPage />} />
          <Route path=":postId" element={<PostPage />} />
        </Route>

        {/* 404 처리 */}
        <Route path="*" element={<NotFoundPage />} />
      </Routes>
    </BrowserRouter>
  );
}

// 중첩 레이아웃
function PostLayout() {
  return (
    <>
      <Header />
      <Outlet />
      <Footer />
    </>
  );
}

// 동적 경로
function PostPage() {
  const { postId } = useParams();
  return <div>Post ID: {postId}</div>;
}

// 프로그래밍 이동
function Example() {
  const navigate = useNavigate();
  return (
    <button onClick={() => navigate("/wishlist")}>위시리스트로 이동</button>
  );
}
```

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

# React Router

- 리액트에서 경로에 따라 페이지를 나누도록 해주는 라이브러리
- 리액트 컴포넌트로 페이지를 나누고 이동하게 해주는 라이브러리
- 공통된 레이아웃으로 컴포넌트 지정  
  & 각 페이지마다 컴포넌트 지정

- api 폴더 - index.js
- assets - 이미지 파일
- components - 리액트 컴포넌트들 / 그 컴포넌트 css
- pages - 페이지용 컴포넌트
- utils - 여러 컴포넌트에 사용하는 함수

## 라우터 설치 및 사용

`npm install react-router-dom@latest`

react-router는 주로 reat-native에서, react-router-dom은 웹 브라우저 전용 기능 포함이라 후자 써야함

```jsx
// 웹 프로젝트에서는 이렇게만 쓰면 됨
import {
  BrowserRouter,
  Routes,
  Route,
  Link,
  useNavigate,
  useParams,
  useLocation,
} from "react-router-dom";
```

## (Brouser)Router

리액트 라우터에서 사용하는 데이터들 가지고 있음

- 현재 주소, 페이지 기록

```jsx
import { BrowserRouter } from "react-router-dom";

function App() {
  // 최상위 컴포넌트에서 감싸기
  return <BrowserRouter> ... </BrowserRouter>;
}
```

## 페이지 분기

```jsx
<Routes>
  // 페이지 경로 / 보여줄 컴포넌트 지정
  <Route path="/" element={<HomePage />} />
  // 컴포넌트 함수 아닌 JSX로 넘김
  <Route path="posts" element={<PostListPage />} />
  <Route path="posts/1" element={<PostPage />} />
</Routes> // 현재 경로와 path prop 일치하는 Route element 컴포넌트 렌더링
```

Routes, Route는 렌더링XX, Fragment처럼 리액트 상에서만 존재하는 컴포넌트

## Link

```jsx
<Link to="/이동할경로">블로그</Link>
// ‘이동할경로’만 쓰면 링크 맨 뒤에 /이동할경로 추가해서 페이지 이동
```

slug 데이터 프로퍼티?

- 각 데이터를 구분하는 고유한 문자열
- id보다 좀 더 의미있는 주소를 만들 때 사용

왜 a 태그 대신 Link 컴포넌트를 사용할까?

## NavLink로 페이지 강조

메뉴에서 사용하는 링크

<Link> 대신 사용 + style prop으로 함수 지정 가능
이 함수에서 리액트 인라인 스타일 객체 리턴
매개변수 객체로 { isActive } 사용 가능
  ㄴ to prop의 경로가 현재 주와 같으면 true 반환

```jsx
function getLinkStyle({ isActive }) {
	return { textDecoration: isActive ? ‘underline’ : undefined, }
}

<NavLink to=‘/경로' style={getLinkStyle}>카탈로그</NavLink>

```

## 하위 페이지 분기

children처럼 부모 컴포넌트에 특정 태그로 감싸거나 디자인 적용하고 싶을 때 Outlet 컴포넌트 활용

1. 감싸고 싶은 상위 Route의 element prop에 Outlet을 가지고 있는 컴포넌트 설정
2. 해당 컴포넌트의 매개변수 children 프로퍼티는 사용X
3. return 안에 children 대신 <Outlet /> 지정
   => 상위 Route에서 하위 Route 감싸며 디자인 적용도 가능

```jsx
<Routes>
  <Route path="/"><HomePage /></Route>
  <Route path="posts" element={<PostLayout />} >
	// 얘는 공통 UI용
    <Route index element={<PostListPage />}  />
	// /post 경로에서 보일 컴포넌트
    <Route path="1" element={<PostPage />}  />
  </Route>
</Routes>
-
import { Outlet } from ‘react-router-dom’;

function PostLayout() {
return <Header/><Outlet /><Footer/>;
```

- children: 부모 컴포넌트가 명시적으로 감싸고 있는 자식 컴포넌트/태그 렌더링
- Outlet: 부모 컴포넌트가 암묵적으로 정의한 하위 라우트의 element 렌더링

## useParams 동적 경로(변하는 경로)

현재 경로가 Route의 path와 매칭될 때 (현재 주소에서), 동적 세그먼트(:postId)를 객체로 변환  
= Route의 path 정의에 따라 값이 결정

1. url 파라미터 `/posts/:postId`
   - url 경로 자체에 변수를 포함시키는 방식
   - :를 붙여서 React Router에서 동적으로 값 get
2. 쿼리 파라미터 `/posts?page=2&sort=desc`
   - url 뒤에 ? 붙여 key=value 형태로 전달
   - 값 여러개 전달 가능

```jsx
<Routes>
  <Route path="/">
    <HomePage />
  </Route>
  <Route path="posts" element={<PostLayout />}>
    <Route index element={<PostListPage />} />
    <Route path=":postId" element={<PostPage />} />
    {/* posId라는 변수로 페이지 경로 받아오기*/}
  </Route>
</Routes>;

import { useParams } from "react-router-dom";

function PostPage() {
  const { postId } = useParams();
  // 현재 URL 경로에서 정의된 동적 파라미터 get
}
```

<details><summary>useParams() 역할/작동방식</summary>
useParams()가 호출된 컴포넌트 렌더링 시, URL의 :postId 부분에 해당하는 값 get

1. url 접속
   - 사용자가 /post/123과 같은 url에 접속 시
   - eact router가 이 url을 <Route path=‘posts/:postId’ /> 와 매칭
2. useParams() 호출
   - 라우트 element 컴포넌트 렌더링
   - useParams() 호출
   - useParams()가 url의 동적부분 read
   - {postid: ‘123} 객체반환
3. 값 추출

   - 반환된 객체에서 123 추출해 postId 변수에 할당

4. {<Link to=`/post/${postId}`>{postName}</Link>}

- 주소가 바뀜

2. <Route path="/posts/:postId" element={<PostPage />} />

- postId를 읽고 이 컴포넌트 렌더링

3. const { postId } = useParams();

- 해당 id값 가져와서 api 호출해 데이터 받아와서 같은 레이아웃에 데이터만 다르게 뿌림

=> url의 동적 값을 쉽게 가져와 서버 API 호출이나 페이지 콘텐츠 로딩에 활용하는 Hook

</details>

## page404

```jsx
// ... Route 맨 마지막에
<Route path="*" element={<NotFoundPage />} />
```

## 리다이렉트 Navigate

```jsx
import { useParams, Navigate } from "react-router-dom";

const { postId } = useParams();
const post = getPost(postId);

if (!post) {
  // post의 초기상태가 null이거나 결과가 undefined
  // post페이지로 바로 리다이렉트
  return <Navigate to="/posts" />;
}
```

## useSearchParams 쿼리 스트링

컴포넌트에서 주소창에 있는 쿼리 파라미터를 가져와서 API 함수로 넘겨주면 검색결과 get

useSearchParams() Hook으로 리액트 라우터에서 쿼리 파라미터값 get

```jsx
import { useSearchParams } from 'react-router-dom';

function PostListPage() {
  const [searchParams, setSearchParams] = useSearchParams();
  // 현재 URL 쿼리 정보 객체(URLSearchParams)
  const filterQuery = searchParams.get(‘파라미터key’);
  // 쿼리 파라미터 value를 getter 함수로 get

  // 1. 검색어 입력값 관리 (실시간 검색)
  const [keyward, setKeyword] = useState(filterQuery);
  const posts = getPosts(filterQuery || '');
  // api 호출 결과 get
  const handleKeywordChange = (e) => setKeyword(e.target.value); // 쿼리 파라미터에 따라 value 자동 변경

  const handleSubmit = (e) => {
    e.preventDefault();
    setSearchParams(keyword ? {
      // 쿼리값 변경해 주소 변경
      keyword // 객체 단축 속성
    } : {});
  }

  {filterQuery && posts.length === 0 ? <NoResult /> : {posts.map(post) => {<Result />}}}

  // 2. 검색 세부설정 업데이트
  const newParams = new URLSearchParams(searchParams); // 기존 쿼리 복사
  newParams.set(‘파라미터, ‘값’); // 특정 파라미터만 변경
  setSearchParams(newParams); // 적용
}
```

## Navigate

```jsx
import { useParams } from "react-router-dom";

function PostPage() {
// URL 파라미터로부터 postId를 가져온다고 가정
const { postId } = useParams();
// API 호출(fetch)이나 미리 정의된 데이터 배열에서 찾는 방식일 수 있음
const post = getPost(postId);

// post가 없는 경우 /posts 페이지로 리다이렉트
if (!post) {
return <Navigate to="/posts" />;
}
return (); // 진짜 렌더링용
}
```

## useNavigate Hook

```jsx
import { useNavigate } from "react-router-dom";

const navigate = useNavigate();

// 코드 사용해서 이동해야 하는 경우에 사용
const handleClick = () => {
  // … API 호출, 상태 업데이트 등 작업 수행
  navigate("/wishlist"); // 해당 함수를 통해 페이지 이동
};
```

## 활용 방식

1. Link
   - **사용자가 클릭해서 페이지 이동할 때**
   - 하이퍼링크, 페이지 이동 버튼/이미지
2. Navigate
   - **특정 경로에서 렌더링 시점에 다른 페이지로 이동시킬 때**
   - ex. 회원 전용 페이지에 로그인 없이 들어와 리다이렉트
   - ex. 상세 페이지 제품 품절/삭제로 리다이렉트
3. useNavigate
   - **특정 코드 실행 이후에 페이지 이동시킬 때**
   - ex. 장바구니 담은 후 장바구니 페이지로 이동
   - ex. 결제 버튼 이후 결제 성공시 결제 완료 페이지로 이동
   - ex. 로그인 완료 후 처음 진입한 페이지로 리다이렉트

## react-helmet: title 설정

```jsx
// 기존 방법
document.title = "something";

// react-helmet
import { Helmet } from "react-helmet";

return (
  <Helmet>
    {" "}
    {/* 태그에 덮어쓰기*/}
    <title>something</title>
  </Helmet>
);
```

## SPA

id가 root인 div 태그 안에 html 노드  
JS로 리액트가 생성한 HTML

**클라이언트사이드 렌더링(Client-side Redering)**

- 웹브라우저에서 JS로 HTML 패이지를 만드는 것
- root div에서 클라이언트사이드 렌더링 (주소 읽고, 해당 경로에 일치하는 컴포넌트 렌더링)
- 클라이언트사이드 렌더링으로 리액트 라우터 사용할 경우 개발 모드와 달리 서버 배포에 따로 설정 필요

#### 싱글 페이지 애플리케이션(Single Page Application)

- Link 태그로 웹 브라우저의 기본 동작 대신 리액트 라우터로  
  **경로에 맞는 리액트 컴포넌트 렌더링, 주소 변경, 웹 브라우저에 기록 추가**

  - 한 HTML 문서 안에서 다른 페이지로 이동 가능
  - api request 없이도 JS 사용해 마치 다른 HTML 페이지 받은 것처럼 흉내

- 하나의 HTML 문서 안에서 JS로 여러 페이지를 보여주는 것  
  (여러 경로의 HTML 문서를 돌아다니는 것이 아닌)
- HTML 문서가 바뀌는 것이 아니기 때문에 api request도 요청XX

## 렌더링 종류

1. Client-side Rendering

   - 웹 브라우저에서 JS로 HTML 파일 생성
   - JS로 변환된 리액트 코드를 웹 브라우저에서 실행해 HTML을 만드는 것
   - 리액트로 작성한 코드는 JS로 변환(트랜스파일링) 가능

2. Server-side Rendering

   - 서버에서 HTML 파일 만들어 리스폰스로 전달
   - 이미 렌더링된 것이 웹 브라우저에 도착해 더 빠른 화면 띄움 가능

3. Static Site Generation
   - 미리 HTML 파일 만들어 서버 배포
   - 서버에서 request 들어오면 HTML 파일 읽어 responce send
   - JS 사용 => 동적인 데이터 가져와 화면 출력 가능

## 렌더링 활용 리액트 기술

1. Next.js

   - 리액트 서버 사이드 렌더링을 편하게
   - HTML 파일 나누듯 JS 파일 나눠 놓으면 곧바로 페이지로 사용 가능 (dislike 리액트 라우터)

2. Gatsby

   - 리액트 코드를 미리 렌더링해 프로젝트 빌드시 HTML 파일로 생성
   - 정적 사이트(소개 사이트, 포트폴리오 사이트)를 리액트로 만들고 싶을 때 사용 추천

3. React Native
   - 안드로이드, ios 공통 코드 한번에 개발 가능
   - JS의 리액트 코드는 앱에서 ios/안드로이드 네이티브 컴포넌트와 연결

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 개념을 하루 단위로 해서 현재 목요일인데 월요일 것 업로드..
- 빨리 날짜도 맞춰놔야겠다

---

## 🚀 내일의 계획

- JS BE express 강의/실습 완
- 스터디 과제들 완료

---
