# 🗓️ 2025-07-17 TIL 15일차

## ✅ 오늘의 성취 (잘한 점)

- 예
- 예

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

### 🔹 주요 개념 정리

### 🔹 예제 코드

<details>
<summary style="font-size: 22px;">📓 메모장</summary>
TIL 15

# Interactive JS

## Event

### Event Handler

js 프로퍼티를 활용한 event(ex.onCllick)는
중요한 이벤트 덮어 쓸 수도 있고
여러개의 이벤트 핸들러를 다룰 수도 없음
이벤트별로 리턴값이 있을 때 그 리턴 값도 다뤄야 해 복잡함

그래서 사용한다!
요소addEventListener(이벤트 타입, 이벤트 핸들러)
요소.removeEventListener(타입, 핸들러)
ㄴ 등록할 때 사용했던 핸들러 무조건 그대로 전달!!
ㄴ functioin() {} 형태 XX 함수 이름으로 전달!!

이벤트 핸들러 () => XX. 등록이 안됨
ㄴ 이건 실행문 (뭔가를 반환한다는 뜻)
ㄴ return문이 없으면 undefined 반환

#### 퀴즈

removeEventListener 메소드:
파라미터로 전달하는 타입과 이벤트 핸들러가 addEventListener 메소드로 등록할 때와 동일 할 때만 이벤트 핸들러를 삭제 가능
(addEventListener가 없으면 removeEventHandler도 무용지물)

addEventListener와 removeEventListener메소드에 사용된 이벤트 핸들러는 모양이 같다고 해서 서로 같은 함수가 아님
각 메소드가 호출된 때 임시로 작성된 것

addEventListener는 안에 함수 선언해도 됨!
근데 removeEventListener는 대상함수가 분명해야 함

### Event Object

어떤 요소를 클릭했는지
클릭한 시점에 마우스 포인터의 위치는 어디였는지
어떤 키를 눌렀는지

이벤트 발생 시 해당 이벤트와 관련된 다양한 정보 담고 있는 이벤트 객체 자동 생성
이벤트 핸들러의 첫번째 파라미터는 이벤트 객체!

function 핸들러명(e) { }
e(vent)는 우리가 만든 게 아니라,
이벤트 핸들러 함수가 실행되었을 때 브라우저가 생성해서 이 함수에 전달해준 객체
에서 자주 사용되는 프로퍼티: type, target
type - 발생한 이벤트의 타입
target - 이벤트가 발생한 DOM 요소

공통 프로퍼티 설명
type 이벤트 이름 ('click', 'mouseup', 'keydown' 등)
target 이벤트가 발생한 요소
currentTarget 이벤트 핸들러가 등록된 요소
timeStamp 이벤트 발생 시각(페이지가 로드된 이후부터 경과한 밀리초)
bubbles 버블링 단계인지를 판단하는 값

마우스 이벤트 프로퍼티 설명
button 누른 마우스의 버튼 (0: 왼쪽, 1: 가운데(휠), 2: 오른쪽)
clientX, clientY 마우스 커서의 브라우저 표시 영역에서의 위치
pageX, pageY 마우스 커서의 문서 영역에서의 위치
offsetX, offsetY 마우스 커서의 이벤트 발생한 요소에서의 위치
screenX, screenY 마우스 커서의 모니터 화면 영역에서의 위치
altKey 이벤트가 발생할 때 alt키를 눌렀는지
ctrlKey 이벤트가 발생할 때 ctrl키를 눌렀는지
shiftKey 이벤트가 발생할 때 shift키를 눌렀는지
metaKey 이벤트가 발생할 때 meta키를 눌렀는지 (window는 window키, mac은 cmd키)

키보드 이벤트 프로퍼티 설명
key 누른 키가 가지고 있는 값
code 누른 키의 물리적인 위치
altKey 이벤트가 발생할 때 alt키를 눌렀는지
ctrlKey 이벤트가 발생할 때 ctrl키를 눌렀는지
shiftKey 이벤트가 발생할 때 shift키를 눌렀는지
metaKey 이벤트가 발생할 때 meta키를 눌렀는지 (window는 window키, mac은 cmd키)

#### 실습

1. items[event.currentTarget].classList.toggle(‘done’)
   1. items = todoList.children 해당 부모요소의 모든 자식 요소를 배열로 저장
   2. event.currentTarget은 인덱스(숫자)가 아님
   3. 그냥 event.currentTaget.classList.toggle(‘done’)만 해도 됨
2. for(el in items){items[el].addEventListener('click',updateToDo);} 1. for in은 객체 순회 함수 1. 인덱스 뿐만 아니라 프로퍼티(속성)까지 순회 2. length, entries, keys같은 것도 순회해서 필요 요소 외에 다른 메서드나 undefined가 나올 수 있음 3. for of로! 2. items[el]은 undefined 1. items[el]은 items[0], items[1]이랑 다름 1. 인덱스가 아닌 요소값임 2. el.addEventListener로!
   \*\* 참고
   구문 i 또는 el의 값 내부 접근 방식 사용 시점
   for (let i = 0; i < items.length; i++) i = 0, 1, 2... → 숫자 인덱스 items[i]로 접근 인덱스 필요할 때 적합
   for (const el of items) el = items[0], items[1]... → 실제 요소 그 자체 요소에 바로 접근 가능 인덱스 필요 없고 요소만 다룰 때 적합
   ++ 근데 왜 for in은 removeEventListener가 제대로 동작하지 않았을지언정 add는 작동했는가?
   JS 배열은 사실 숫자 인덱스 기반의 객체임
   for in은 키를 반환
   for of는 값을 반환
   그래서 for in을 해도 배열형태기 때문에 반환값은 그들의 키인 문자 1 2 3
   => 숫자인덱스든 숫자형태의 문자열인덱스든 동일하게 작동해 동작할 수도?

++ 그럼 왜 코드는 똑같은데 add는 되고 remove는 안됐을까?
코드상으로는 똑같지만 for in안에서 값 외에 다른 속성이 돌다가

1. 정상적인 요소가 아닌 곳에 이벤트 걸거나
2. 이벤트가 아예 안걸리거나
3. 브라우저가 내부적으로 달리 처리할 수 있음
   => 결과적으로 정확히 같은 참조가 등록된게 아닐수도!
   브라우저가 다르게 인식해서 remove 동작 ㄴㄴ

### Event Bubbling

한 요소에 이벤트 발생 시 같은 타입 이벤트에 한해 부모요소 핸들러까지 동작
e.target은 버블링이 되지 않는다!!\*\*
ㄴ 처음 이벤트 발생 요소

e.currentTarget
ㄴ 이벤트 핸들러 등록된 요소

e.stopPropagation()
ㄴ 버블링 제한 함수

근데 가급적이면 버블링 피하는게 좋다?
아이템 영역만큼의 이벤트 발생 범위 사라짐

### Event Capturing

1. 캡처링 단계 - 이벤트가 하위 요소로 전파
2. 타깃 단계 - 이벤트가 실제 타깃 요소에 전달
   1. 가장 처음 이벤트 핸들러가 동작하게 되는 순간
3. 버블링 단계 - 이벤트가 상위 요소로 전파

window 객체부터 target 객체까지 이벤트 전파 -> 이밴트 핸들러 동작 -> window 객체로 이벤트 전파

요소.addEventListener("click", 함수, (capture:)true);

#### 실습

<div id="main">...</div>에도 이벤트 핸들러를 등록
=> <div id="main">...</div>에 등록된 이벤트 핸들러도 동작

### Event 위임?

아이템 각각에 대한 이벤트 핸들러 아래에 새 코드 추가시 해당 코드에는 이벤트 핸들러 동작X => 위임해주기

```js
for (let item of list.children) [
	item.addEventListener(‘click’, function(e) {
		e.target.classList.toggle(‘done’);
	});
}
```

⬇️

```
list.addEventListener(‘click’, function(e) {
e.target.classList.toggle(‘done’);
}); //e.target은 내가 클릭한 실제 요소
```

근데 li가 아닌 애 누르면 이상하게 작동할수도! 그래서

```
list.addEventListener('click', function(e) {
  if (e.target.tagName === 'LI') { //태그이름값 대문자
    e.target.classList.toggle('done');
  }
});

// or

list.addEventListener('click', function(e) {
	if (e.target.classList.contains(‘item’)) {
		li.classList.toggle('done');
	} // is it contained in class property?
});
```

#### 실습

✅ 정리: 왜 부모에 붙이고 자식에 반응하는가?

- 브라우저의 버블링 구조 덕분에 가능
- 부모 요소 하나만 감시하면 자식들의 클릭을 전부 다룰 수 있어서 효율적
- 클릭된 실제 요소는 event.target으로 구분해서 처리

```
function updateToDo(event) {
  if (event.target.tagName === 'LI') {
    event.target.classList.toggle('done');
//event.target은 그 이벤트 요소 딱 하나!!
// 2. 그 조건을 가진 해당 이벤트 요소에만 이런 행동을 해
  }
}


toDoList.addEventListener('click', updateToDo);
// 1. 이벤트리스너는 부모요소에 야 클릭하면 이 함수 실행해
```

1. 사용자가 <li> 클릭 → 브라우저가 이벤트 객체 (MouseEvent)를 생성
2. li에 이벤트 핸들러가 있으면 먼저 실행됨 (Target Phase)
3. 그다음 브라우저는 해당 li의 부모인 ul을 확인하고:
   - ul에 리스너가 등록돼 있으면 해당 핸들러 함수 호출
   - 없다면, 그 위의 body, html 등으로 계속 올라감
4. 이 과정을 DOM 트리를 타고 올라가며 반복함

=> 어차피 부모 요소 하나에만 이벤트 리스너를 붙이고, 이벤트가 발생한 실제 대상(event.target)에 맞게 처리하면,
자식 노드에서 이벤트가 발생해도  부모에 붙은 리스너가 실행되어서
효율적으로 관리

### 브라우저 기본 동작

event.preventDefault();
ㄴ 브라우저의 기본동작 제한

ex
link 요소의 eventListener 내장함수로 사용시 이동 안함
input 요소의 if 분기로 checkbox.checked boolean으로 텍스트 인풋(keydown) 기능 막기 가능
=> EventListener 이벤트 타입별로 막기 가능!

꼭 필요한 경우에만 주의해서 사용하기

#### 퀴즈

preventDefault()는
이벤트 객체(event)의 메서드임
이벤트가 발생한 대상 요소(event.target)의 메서드 아님

## 다양한 Event

### mouse button event

하나의 동작에 여러 이벤트 발생할 수도
ex) 더블클릭

- mousedown
- mouseup
- click
- mousedown
- mouseup
- click
- doubleclick

마우스 클릭 형태 프로퍼티 button
e.button

이벤트 발생 순서가 운영체제 별로 달라질 수도 있다는 점..??

#### 실습

으아아아아…
오답노트

- e.target~은 클릭 이벤트 발생한 해당 요소!를 가져오는 것이기 때문에 특정 요소를 가져오려면 따로 요소 데이터를 서치해 접근해야함
- 마우스 클릭 위치에 따른 속성은 button (type은 더블클릭인지 눌렀고 뗐는지 등등)
- class 속성에 값을 추가하려면 add함수를 사용해야함

#### mouse movement event

이벤트 타입 설명
mousedown 마우스 버튼을 누르는 순간
mouseup 마우스 버튼을 눌렀다 떼는 순간
click 왼쪽 버튼을 클릭한 순간
dblclick 왼쪽 버튼을 빠르게 두 번 클릭한 순간
contextmenu 오른쪽 버튼을 클릭한 순간
mousemove 마우스를 움직이는 순간
mouseover 마우스 포인터가 요소 위로 올라온 순간
mouseout 마우스 포인터가 요소에서 벗어나는 순간
mouseenter 마우스 포인터가 요소 위로 올라온 순간 (버블링X)
mouseleave 마우스 포인터가 요소에서 벗어나는 순간 (버블링X)

movement property

- clientX, clientY (창 기준의 마우스 위치)
- pageX, pageY (문서 전체 기준의 마우스 위치)
- offsetX, offsetY (이벤트 발생 target 기준의 마우스 위치)

mouseover / mouseout

```
function Event(e) { //  자식 요소에 이벤트
	if (e.target.classList.contains(‘cell’)) {
		e.target.classList.toggle(‘on’);
	}
}
부모요소.addEventListener(‘mouseover’, Event);
부모요소.addEventListener(‘mouseover’, Event);
// 버블링 이용해 부모에 감시 위임
```

- .relatedTarget (이벤트 발생 직후 마우스 위치 요소 반환)

mouseenter / mouseleave
자식 요소의 영역 계산X
ㄴ 각 자식요소위를 움직여도 다 같은 위치로 인식한다는 뜻인듯?
=> 핸들러가 자식 요소에까지 영향끼치길 원하면 over/out
=> 자식요소 말고 해당 요소에만 다루고 싶으면 enter/leave

#### 실습

1. datta-set은 클래스 아닌 data 속성
   1. e.target.dataset.속성
2. classList.add()는 반환 안함
   1. 변수에 할당하는 애가 아님
3. target.removeChild()는 인자값 필요
4. e.target.dataset.title은 값
   1. 근데 classList.contains(클래스명)
   2. 속성에 값이 있냐 없냐 판별시 if (e.target.dataset.속성명)
5. 속성의 값을 꺼냈으면 해당요소내에에 할당!
   1. 요소.textContent = e.target.dataset.title
6. remove(document.querySelector(클래스명)
   1. 걍 첫번째 요소를 지움
   2. 타겟팅을 해야 그 요소를 지울 수 있음
   3. e.target.querySelector(클래스명)

### keyboard event

이벤트 타입 설명
keydown 키보드의 버튼을 누르는 순간
keypress 키보드의 버튼을 누르는 순간 ('a', '5' 등 출력이 가능한 키에서만 동작하며, Shift, Esc 등의 키에는 반응하지 않음)
keyup 키보드의 버튼을 눌렀다 떼는 순간

- key 계속 누르고 있을 땐 keydown만 연속적으로 발생하고, keypress는 처음 한번만 발생
- 영어 아닌 글자에는 keypress 반응X
  => keypress 권장X, 대신 keydown 쓰기

#### keyboard event property

- event.key : 입력받은 키 (ex.A, a, Shift)
- event.code : key 위치 (ex.keyA, ShiftRight, ShiftLeft)

포커스 이벤트
이벤트 타입 설명
focusin 요소에 포커스가 되는 순간
focusout 요소로부터 포커스가 빠져나가는 순간
focus 요소에 포커스가 되는 순간 (버블링X)
blur 요소로부터 포커스가 빠져나가는 순간 (버블링X)

### input tag event

이벤트 타입 설명
change 입력된 값이 바뀌는 순간
input 값이 입력되는 순간
select 입력 양식의 하나가 선택되는 순간
submit 폼을 전송하는 순간

### scroll event

이벤트 타입 설명
scroll 스크롤 바가 움직일 때

윈도우 창 이벤트
이벤트 타입 설명
resize 윈도우 사이즈를 움직일 때 발생

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 예
- 예

---

## 🚀 내일의 계획

- 예
- 예

---
