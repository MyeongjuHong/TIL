# 🗓️ 2025-10-23 TIL 77일차

## ✅ 오늘의 진행 (완료한 작업)

- repository branch rulesets 수정
- 승전님 git token 에러 회의
- 주현님 컴포넌트 공통화 회의
- 카드 생성 기능 구현
  - cardRepository.js
  - cardService.js
  - cardController.js
  - cardRoute.js

---

## 🛠️ 작업 상세

### 🔹 구현/수정한 기능

- 예

### 🔹 발생한 이슈 & 해결 과정

- 예

### 🔹 미해결/보류된 이슈

- 예

---

## 📓 작업 메모 (코드/아이디어/레퍼런스)

<details>
<summary style="font-size: 22px;">📝 메모장</summary>

## 💭 4️⃣ MJ님이 직접 점검해볼 포인트

이제 아래 질문에 대해 MJ님 스스로 답해보세요 👇
(이게 진짜 실력이 됩니다)

1. `createCard` 함수는 **`userId`**를 어디서 받아야 할까요?
   → controller? middleware? `Controller에서!`
   => 잘 모르겠음 안그래도..ㅠㅠ

   - `userId`는 로그인한 유저 정보 => **JWT 토큰 인증 `미들웨어`에서 req.user**에 넣어주는 게 일반적
   - 이후 `Controller`에서 req.user.id를 꺼내서 Service (또는 Repository) 로 전달

2. 트랜잭션 내부에서 `photocard`를 만든 다음
   `userPhotocard`에 그 id를 넣어야 하는데,
   **비동기 흐름상 photocard.id는 안전하게 접근 가능한가요?** (왜?)
   => await 때문에!!

   - await이 Promise를 resolve한 이후 코드가 실행
   - photocard가 DB에 저장되고 id가 확정된 시점 이후에만 userPhotocard가 실행

3. `UserPhotocards` 모델에 `trade_info_id`가 **필수 필드**로 되어 있는데,
   새로 생성할 때 이 값은 어떻게 처리할 계획인가요?
   => 와 내가 딱 QUES로 남긴 주석을 질문으로;;ㅋㅋㅋ 힌트 좀 주라

4. 현재 `UserPhotocards`의 relation 중
   `TradePosts`는 아직 생성되지 않은 상태일 텐데,
   그러면 `trade_info_id`는 nullable이어야 하지 않을까요?
   (즉, DB 스키마 수정이 필요한지 확인)
   => 웅 그니까ㅎ 백엔드 팀장이랑 합의해볼까?

---

## 💭 1️⃣ `userId`는 어디서 받아야 할까? (controller? middleware?)

👉 **Controller에서 받아오는 게 정석이에요.**

이유는 이렇게 됩니다:

- `userId`는 **로그인된 사용자 정보**에서 나오는 값이죠.
- 로그인한 유저 정보는 **`authMiddleware`** 같은 인증 미들웨어에서 `req.user`에 담아줍니다.
- 그러면 **controller**에서는 `req.user.id`를 꺼내서 **service/repository**로 넘겨주면 됩니다.

즉, 이런 흐름이에요:

```
authMiddleware → req.user = { id: 10 }
↓
controller: createCard(req.user.id, req.body)
↓
service → repository
```

🧩 **결론**

> `middleware`는 “user 정보를 넣어주는 역할”,
> `controller`는 “그걸 꺼내서 함수에 넘겨주는 역할”.

---

## 💭 3️⃣ `trade_info_id`는 필수인데, 아직 생성 안 됐을 때는?

좋아요 이건 백엔드 설계 단계의 아주 중요한 논리입니다 ⚙️

현재 `UserPhotocards` 모델은 이렇게 돼 있죠 👇

```prisma
trade_info_id Int // FK TradesPosts
```

여기서 `trade_info_id`는 **“거래 게시물”**의 정보인데
“카드를 처음 만들 때”는 거래 게시물이 존재하지 않아요.

즉,

- 지금은 “판매 중이 아님” 상태니까 `trade_info_id`가 **없어야 정상**이에요.
- 근데 현재 스키마에선 `trade_info_id`가 _필수 필드(Int)_ 이기 때문에,
  null을 못 넣죠.

이건 두 가지 선택지가 있습니다:

### 🅰️ (가장 자연스러운 방법)

DB 스키마 수정:

```prisma
trade_info_id Int? // nullable로 변경
```

→ 이렇게 바꾸면 “거래글이 없는 카드”도 정상 저장 가능.

### 🅱️ (임시 꼼수)

trade_info_id에 더미 값 (예: 0) 넣기.
하지만 이건 **DB 무결성 깨지는 위험한 방식**이라 비추천 ❌

> ✅ **정답**: 백엔드 팀장님께 스키마 변경 제안하세요.
>
> > “UserPhotocards의 trade_info_id는 카드 최초 생성 시 존재하지 않으니 nullable이 자연스러울 것 같습니다.”

이 한 문장만 던져도 백엔드 이해도 높다고 느낄 거예요 👍

---

## 💭 4️⃣ `prismaTx`, `data`, `creator_id` 네이밍 관련 Q&A

좋아요, 디테일 파헤쳐봅시다 👇

---

### 🔹 `prismaTx` / `tx` 네이밍 이유

`prisma.$transaction()` 안에서는 보통 이렇게 씁니다:

```js
await prisma.$transaction(async (tx) => {
  await tx.user.create(...);
});
```

- `tx`는 **transaction client**의 약자예요.
- 그냥 `prisma` 대신 쓴다고 보면 됩니다.
  (트랜잭션 안에서 실행되는 별도의 클라이언트니까 이름만 구분해주는 것)

`prismaTx`나 `tx` 둘 다 OK,
중요한 건 팀에서 일관성 있게 쓰는 것.

---

### 🔹 `data`는 Prisma의 고정 키워드

모든 create/update 메서드에서 Prisma가 요구하는 **입력 객체 이름**이에요.

```js
prisma.model.create({
  data: {
    // 여기에 실제 데이터 필드들 작성
  },
});
```

즉, 이건 개발자가 정한 이름이 아니라 **Prisma API 규칙**이에요.

---

### 🔹 `creator_id` vs `user_id` vs `userId`

이건 **DB 필드 이름**을 기준으로 맞추면 됩니다.

- Prisma 모델에서 `creator_id`라고 되어 있으니까
  → `data`에도 `creator_id`로 넣어야 해요.
- 하지만 코드 변수명(`userId`)은 JS 스타일로 camelCase를 써도 됩니다.

즉 👇

```js
data: {
  creator_id: userId;
}
```

이건 완전히 자연스러운 형태예요.

---

### 🔹 `createdAt`, `updatedAt`은 자동 관리됨

Prisma의 `@default(now())` + `@updatedAt` 덕분에
**명시하지 않아도 Prisma가 알아서 넣어줍니다.**
따라서 지금처럼 안 써도 100% 괜찮아요 👌

---

## 💡 요약 리마인더

| 항목                     | 결론                                     |
| ------------------------ | ---------------------------------------- |
| `userId`                 | controller에서 req.user.id로 받아서 전달 |
| `await`                  | photocard.id 안전하게 접근 가능          |
| `trade_info_id`          | nullable로 바꾸는 게 설계상 맞음         |
| `prismaTx`               | 트랜잭션용 Prisma client 이름일 뿐       |
| `data`                   | Prisma 규칙 키워드 (필수)                |
| `creator_id`             | DB 필드명 기준으로 작성                  |
| `createdAt`, `updatedAt` | 자동 관리됨                              |

---

### ② ❓ `next()`를 안 쓰는 이유?

👏 완벽하게 짚으셨어요.

`next()`는 **Express의 미들웨어 체인**에서만 사용합니다.
즉,

- controller나 middleware 내부: `next(err)`
- service나 repository 내부: 그냥 `throw err`

왜냐면 service는 **순수 로직 함수**로 설계돼야 해서
Express에 의존하지 않아요.

💡 정리

| 위치                    | 에러 처리 방식 |
| ----------------------- | -------------- |
| Controller / Middleware | `next(err)`    |
| Service / Repository    | `throw err`    |

### ④ ❓ prismaTx, error 흐름까지 완성된 전체 구조는?

지금 MJ님이 만든 흐름은 완벽히 다음과 같이 이어집니다 👇

```
🧩 authMiddleware (req.user = 로그인 유저정보)
    ↓
🧩 cardController
      - const { id: userId } = req.user;
      - const result = await cardService.createCardService(userId, req.body);
      - res.status(201).json(result);
    ↓
🧩 cardService
      - userId, 필수값 검증
      - cardRepository.createCard() 호출
    ↓
🧩 cardRepository
      - prisma 트랜잭션으로 Photocards + UserPhotocards 생성
```

이게 바로 **정석적인 MVC + 계층적 책임 분리 패턴**이에요.
(이 정도면 팀 코드리뷰 때 “아 구조 잘 짜네” 소리 듣습니다.)

---

## ✨ 개선 포인트 (아주 소소한 부분)

2️⃣ 검증 로직을 함수로 빼면 나중에 테스트 용이합니다 👇

```js
function validateCardData(cardData) {
  const required = ["name", "grade", "genre", "price", "total_count"];
  for (const field of required) {
    if (!cardData[field]) {
      return false;
    }
  }
  return true;
}
```

---

### 1️⃣ try-catch 전체 감싸기 (Q. 꼭 trycatch를 라우트 전체에 감싸는지)

- Express에서 `async` 라우트는 **Promise가 reject되면 에러가 미들웨어로 안 넘어가는 경우**가 있어요.
- 그래서 **라우트 전체를 try-catch로 감싸고, catch에서 `next(error)` 호출**하는 방식이 안전합니다.
- 요즘은 `express-async-errors` 같은 라이브러리를 쓰면 try-catch 없이도 되지만,
  기본 Express만 쓰면 지금처럼 감싸는 게 정석이에요. ✅

---

### 2️⃣ `req.user.id` vs authMiddleware

- 맞아요, authMiddleware에서 로그인 유저 정보를 `req.user`에 담아줍니다.
- 일반적으로 user 객체 구조는 팀마다 달라서, `req.user.id`가 맞는지 확인 필요
  → 혹은 `req.user.userId` 같은 구조일 수도 있음.
- card 전용 middleware는 지금 “카드 생성”에는 별도로 필요 없어요.
  → authMiddleware만 있으면 userId 확보 가능.

---

### 3️⃣ 필수값 검증 중복 문제

- 질문 그대로, `cardService`에서도 똑같이 필수값 검증을 하고 있어서 **중복**이 보이네요.

💡 정석 패턴:

1. Controller에서는 **HTTP 요청 레벨 검증** 정도만 수행
   (예: body가 비어 있는지, JSON 형식인지 등)
   ```js
   // HTTP 요청 레벨 검증 (body 비었는지, JSON 형식인지)
   if (!cardData || Object.keys(cardData).length === 0) {
   }
   // req.body가 전자(null, undefined, false, 0, '')이거나 후자({}: 빈 객체)일 때를 거름
   // 1. 미들웨어(express.json() 등)이 아예 안쓰여서 파싱 실패로 인해 undefined
   // 2. 클라이언트가 Content-Type 없이 요청을 보내서 파싱 실패로 인해 undefined
   // 3. 서버 코드에서 실수로 req.body = null 또는 req.body = false 등으로 초기화했을 때
   ```
2. Service에서는 **비즈니스 로직 레벨 검증**
   (예: 필수 필드 존재 + 타입/범위 체크, userId 존재 여부 등)

즉, Controller 검증은 “빠르게 잡아주는 1차 필터”라고 생각하면 돼요.
Service에서 다시 확인하는 건 “안전망”이죠. ✅

```js
// JSON 형식 검증은 app.use(express.json()) 사용 시 자동으로 400에러 return
// 그래서 try-catch로 JSON 파싱 실패 여부 확인 or 미들웨어 수준에서 처리
```

---

### 4️⃣ 구조 리뷰

```
authMiddleware → req.user.id 확보
↓
cardController.post("/cards") → body 기본 검증
↓
cardService.createCardService(userId, req.body) → 필수값 + biz 로직 검증 + repository 호출
↓
cardRepository.createCard → prisma 트랜잭션
```

- 지금 구조가 **계층별 책임 분리**를 잘 보여주고 있음
- Controller는 Express, HTTP 레벨,
- Service는 핵심 로직 + 검증,
- Repository는 DB 처리만 담당

</details>

---

## 🧠 오늘의 회고 (아쉬움 & 배운 점)

- 예

---

## 🚀 내일의 계획

- 예
