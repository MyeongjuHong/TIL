# 🗓️ 20yy-mm-dd TIL n일차

## ✅ 오늘의 진행 (완료한 작업)

- \[오늘 한 작업 요약]

---

## 🛠️ 작업 상세

### 🔹 구현/수정한 기능

- 예

### 🔹 발생한 이슈 & 해결 과정

- 예

### 🔹 미해결/보류된 이슈

- 예

---

## 📓 작업 메모 (코드/아이디어/레퍼런스)

<details>
<summary style="font-size: 22px;">📝 메모장</summary>

### errors.js 파일 변경

```js
function createError(code, errorCode, message) {
  const error = new Error(message);
  error.code = code;
  error.data = { errorCode }; // 기존 { errorCode, message };
  return error;
}
```

#### 💡 프론트용 참고 사항

- 프론트에서는 error.data.errorCode로만 분기하면 됨 ✅
- 사용자 메시지는 error.message로만 관리 → 다국어 처리, UI 대응 쉬움 ✅
- 서버 로깅 구조 간결화 (중복된 문자열 제거) ✅

그 말, 너무 솔직하고 현실적이에요 MJ.
지금 그 “왜 난 이런 생각을 못하지?”라는 감정은 사실 **성장하고 있다는 신호**예요.
이건 “나도 저 사고 과정을 할 수 있게 되고 싶다”는 의식이 생겼다는 뜻이거든요.

근데 이 부분, 조금만 각도를 바꿔서 볼게요 👇

---

### 🌱 1️⃣ “나도 저렇게 되고 싶다”는 게 이미 첫 단계예요

많은 초급 개발자들이 **“문제를 고치는 코드”만 보려고 하는데**,
MJ는 이미 “그 사고 과정”을 보고 있어요.
이건 완전히 다른 수준이에요.

즉, 지금은 **“사고력을 키우는 학습 단계”**에 딱 와있어요.
이건 시간만 걸릴 뿐, 방향은 이미 맞아요.

---

### 🧩 2️⃣ 사고 플로우는 “패턴 기억 → 질문 습관화 → 연결 시도” 과정이에요

개발자들의 ‘문제 해결 사고’는 타고난 게 아니라,
아래 루틴이 쌓여서 생겨요:

1. **패턴 기억**

   - 예: “단일 데이터만 생긴다 → 반복문이나 createMany 써야 하나?”
   - 이런 패턴을 여러 번 본 사람은, 다음에도 자연스럽게 그쪽으로 떠올려요.

2. **질문 습관화**

   - “지금 데이터가 1개만 생기는 이유는 뭐지?”
   - “이게 DB 설계 문제인가, 로직 문제인가?”
   - 이렇게 질문을 습관처럼 던지는 게 사고를 열어요.

3. **연결 시도**

   - “이거 전에 비슷한 문제 어디서 본 적 있나?”
   - “그땐 insert 한 번만 했었지... 그러면 반복문이네.”

이걸 꾸준히 훈련하면,
나중엔 자연스럽게 “이건 DB에서 반복적으로 insert 되게 해야 하네” 같은 직관이 생겨요.

---

### ⚙️ 3️⃣ 개발 사고 훈련법 (실전용)

다음 문제 해결할 때마다 이 루틴을 써보세요:

| 단계             | 질문                                              | 목적                     |
| ---------------- | ------------------------------------------------- | ------------------------ |
| 🔍 정의          | “이 코드는 무엇을 하려는가?”                      | 요구사항 명확히 인식     |
| 🧠 관찰          | “현재 동작은 어떻게 다른가?”                      | 버그/불일치 포착         |
| 🔗 원인 추론     | “차이는 어디서 생겼지?”                           | 로직 or 데이터 흐름 추적 |
| 💡 패턴          | “이런 상황을 본 적 있나?”                         | 경험 패턴 연결           |
| 🛠️ 해결 아이디어 | “내가 바꾸려면 어떤 부분을 반복/추상화해야 하지?” | 로직 구성                |

이걸 매번 의식적으로 연습하면,
나중엔 머릿속에서 자동으로 돌아가요.

---

### 🌷 4️⃣ MJ에게 꼭 하고 싶은 말

MJ는 “왜 나는 저렇게 생각 못하지?”가 아니라
이미 “어떻게 하면 저렇게 생각할 수 있을까?”라고 묻고 있어요.
그건 **논리적 사고를 배우는 가장 중요한 문장**이에요.

이건 지능이나 센스 문제가 아니고,
단지 “사고를 훈련하는 시간”의 차이에요.
(실제로 시니어 개발자들도, 초반엔 다 같은 고민을 했어요.)

---

## 3️⃣ 요약하자면

| 표현                        | 실제 타입 | 내부값                  | map 가능? | 설명                                   |
| --------------------------- | --------- | ----------------------- | --------- | -------------------------------------- |
| `Array(5)`                  | 배열      | empty × 5               | ❌        | 값 없는 슬롯만 있는 배열               |
| `Array(5).fill(null)`       | 배열      | null × 5                | ✅        | 실제 값이 들어있는 배열                |
| `Array.from({ length: 5 })` | 배열      | undefined × 5           | ✅        | array-like → 실제 배열로 변환          |
| `{ length: 5 }`             | 객체      | key: 'length', value: 5 | ❌        | 그냥 객체, array-like로 JS가 특별 취급 |

즉, **array-like는 “length가 있고 인덱스 키를 사용할 수 있는 객체”**를 의미하며,
그냥 JS가 정의한 **특수 규약일 뿐**이에요. 타입 자체가 다르다는 뜻은 아니에요.

---

정리하자면:

1. **empty ≠ undefined ≠ null**
2. `{ length: n }` 자체는 그냥 객체
3. array-like라 부르는 건 JS가 Array.from에서 “특별 처리”하기 때문
4. `{ a: 1 }`은 length 없으니까 array-like 아님

---

### 1️⃣ `{ length: total_count }` 자체는

- 그냥 일반 객체(Object)예요.
- `"length"`라는 키에 숫자가 들어있는 **일반 프로퍼티**일 뿐이에요.
- JS 엔진이 특별히 “이건 배열이야”라고 생각하지 않아요.

---

### 2️⃣ Array.from()이 하는 일

- **array-like 객체**(length 속성이 있고, 0~length-1 인덱스 접근이 가능한 객체)를 만나면
  → `length` 값을 읽어서 **그 길이만큼 실제 배열을 생성**
  → 각 요소를 기본 `undefined`로 채움
- 필요하면 두 번째 인자로 **mapFn**을 받아서 각 요소를 변환 가능

즉 Array.from({ length: 5 }) → `[undefined, undefined, undefined, undefined, undefined]`

---

### 3️⃣ Array()랑의 차이

- `Array(n)` → 길이만 n인 **empty slot 배열**
  → 값이 실제로 없어서 map, forEach 불가
- `Array.from({ length: n })` → undefined 값 채워진 배열 → map 가능

> 핵심 차이: Array.from은 “length 프로퍼티 읽고 실제 값(undefined) 채워 넣는다”
> Array(n)은 “길이만 만들고 값은 넣지 않는다”

---

즉 MJ 말대로

> `{ length: total_count }`는 일반 객체지만, Array.from이나 일부 Array 메서드가 **특별히 length를 읽어서 배열을 만들어주는 것**
> 그리고 요소들을 undefined로 채우는 거

---

## 🧭 6️⃣ 핵심 요약 정리

| 구분       | array-like | iterable | 예시            | Array.from() 가능? | for...of 가능? |
| ---------- | ---------- | -------- | --------------- | ------------------ | -------------- |
| 객체       | ❌         | ❌       | `{ a: 1 }`      | ❌                 | ❌             |
| array-like | ✅         | ❌       | `{ length: 3 }` | ✅                 | ❌             |
| iterable   | ❌         | ✅       | `'hi'`, `[1,2]` | ✅                 | ✅             |

---

✅ **결론 한 줄 요약**

> `{ length: 5 }`는 array-like 객체이고 iterable은 아니며,
> `Array.from({ length: 5 })`는 [undefined × 5]인 배열을 만든다.
> `Array(5)`는 [empty × 5]이고, `Array(5).fill(null)`은 [null × 5]다.

---

</details>

---

## 🧠 오늘의 회고 (아쉬움 & 배운 점)

- 예

---

## 🚀 내일의 계획

- 예

강점
협업

지원동기
- 개발팀이 왜 나한테 맞는지, 
1. 백엔드가 왜 나한테 맞는지
2. 백엔드가 왜 내 장점인지
3. 내가 왜 백엔드를 좋아하는지

