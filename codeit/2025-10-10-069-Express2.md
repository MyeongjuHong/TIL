# 🗓️ 2025-10-10 TIL 69일차 Express

## ✅ 오늘의 성취 (잘한 점)

- 예
- 예

---

## 📚 오늘의 학습 (배운 점)

- 미들웨어
  - req, res 다루기
  - 에러 핸들링
  - 내장 미들웨어
    - express.json()
    - express.urlendcoded()
    - express.static()
  - 서드파티 미들웨어 (외장 미들웨어)
    - cookie-parser
    - morgan
    - cors
    - multer
- 라우터
- 파일 업로드

### 🔹 핵심 주제

### 🔹 주요 개념 정리

### 🔹 예제 코드

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

# 미들웨어

## req, res 다루기

> ### 하나의 요청을 여러 미들웨어 거쳐 처리 시 각 미들웨어의 req는 동일하게 공유!

## 에러 핸들링

```jsx
import express from "express";

const app = express();

function errorHandler(err, req, res, next) {
  next(new Error()); // 동기 비동기 모두 충돌 없이 안전하게 처리 가능
}

// ...

app.use(errorHandler);
```

## 내장 미들웨어

### express.json()

```jsx
import express from "express";

const app = express(); // express 사용하겠음
app.use(express.json()); // req.body에 있는 json 문자열을 js 객체로 변환
```

### express.urlendcoded()

```jsx
app.use(express.urlencoded({ extended: true }));
// form post 데이터를 js 객체로 변환해 req.body에 할당
// extended: true → 중첩 객체 파싱 가능

app.post("/signup", (req, res) => {
  // express.urlencoded() 미들웨어로
  // application/x-www-form-urlencoded 형식으로 온 데이터를
  // req.body에 할당 가능
  console.log(req.body);
});
```

### express.static()

```jsx
import express from "express";
const app = express();
app.use(express.static("public"));
app.listen;

// http://localhost:3000/codeit.png로 이동시 파일 확인 가능
// GET http://localhost:3000/codeit.png 이렇게 하면 프론트엔드에서 res로 뭐가 오는데?
```

```javascript
// 프론트는 이 바이너리 형식의 이미지 데이터를 화면에 보여주거나, 파일로 저장, 또는 캔버스에서 조작 가능
fetch("http://localhost:3000/codeit.png")
  .then((res) => res.blob()) // 바이너리 데이터를 Blob 객체로 변환
  .then((blob) => {
    const url = URL.createObjectURL(blob); // Blob -> 브라우저에서 사용할 수 있는 URL
    const img = document.createElement("img");
    img.src = url; // 이미지 요소에 URL 연결
    document.body.appendChild(img); // 화면에 표시
  });
```

- 핵심:

  - `fetch`로 바이너리를 가져옴 → `Blob` 객체로 변환
  - `URL.createObjectURL()` → 브라우저가 읽을 수 있는 임시 URL 생성
  - `<img>` 태그에 연결하면 이미지 렌더링 완료

### 서드파티 미들웨어 (외장 미들웨어)

### cookie-parser

클라이언트가 헤더로 보내온 cookie를 문자열이 아닌 객체 형태로 파싱

```shell
npm i cookie-parser
```

```js
app.use(cookieParser());
// cookie-parser 사용시 req.cookie로 객체 형태의 쿠키 접근 가능
// req.headers.cookie는 문자열 형태
```

### morgan

클라이언트가 보낸 요청을 로그로 남기는 미들웨어

```shell
npm i morgan
```

```js
import morgan from "morgan";
const mode = process.env.NODE_ENV === "production" ? "combined" : "dev";
// [options: tiny, dev, combined, common, short, tiny]
// 개발 환경에서는 dev 형식을 사용하는 것이 좋으며, 배포 환경에서는 combined 형식을 사용하는 것이 좋음
// tiny : 기본 출력 형식
// dev : 개발자 친화적 출력 형식
// combined : 로그 파일에 적합한 출력 형식
// common : 기본 출력 형식 + 요청 메서드, 상태 코드, 응답 시간 추가
// short : 기본 출력 형식 + 요청 메서드, 상태 코드, 응답 시간 추가
// tiny : 기본 출력 형식 + 요청 메서드, 상태 코드, 응답 시간 추가
// app.use(morgan("common"));
app.use(morgan(mode));
```

++) 의미있는 데이터 로깅 툴 hotjar

### cors

서버 도메인 & 외부 도메인의 서버 내 리소스 접근을 제어

```shell
npm i cors
```

```js
import express from "express";
import cors from "cors";

const app = express();
app.use(
  cors(
    {
      // 일반적인 cors 설정 권장사항
      origin: "http://localhost:3000", // 개발 중인 프론트엔드 도메인
      credentials: true,
    },
    {
      methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"], // 허용되는 메서드
      allowedHeaders: ["Content-Type", "Authorization"], // 허용되는 헤더
    }
  )
);
```

### multer

- 'Content-Type'이 'multipart/form-data' 형식의 요청 파싱
- req.file, req.files, req.body에 할당
  주로 파일(이미지, 문서) 요청에 사용

```shell
npm i multer
```

```js
import express from "express";
import multer from "multer";

const app = express();
// app.use(express.multer()); // 전역 사용시 파일 없는 요청에도 적용되어 오버헤드
const upload = multer({ dest: "uploads/" });

// 특정 라우트에만 multer 적용
app.post('/profile', upload.single('avatar'), function(req, res, next) => {})
```

⚙️ multer의 주요 메서드
| 메서드 | 설명 |
| ------------------------------------- | ---------------------------------- |
| `upload.single('fieldname')` | 단일 파일 업로드 처리 |
| `upload.array('fieldname', maxCount)` | 여러 개 파일 처리 |
| `upload.fields([{ name, maxCount }])` | 여러 필드의 파일 처리 |
| `upload.none()` | 파일 없이 multipart/form-data의 텍스트만 처리 |

```js
const storage = multer.diskStorage({
  destination(req, file, cb) {
    cb(null, "uploads/"); // 저장 경로
  },
  filename(req, file, cb) {
    // 파일 이름 중복 방지
    cb(null, Date.now() + "-" + file.originalname);
  },
});

const upload = multer({ storage }); // dest 옵션 대신 저장 경로 & 파일 형식 직접 커스터마이징 가능
```

# 라우터

## 라우터 모듈 분리하기

`express.Router().route('/')`와 `app.route('/')`는 **역할 범위(scope)** 가 다름!  
둘 다 **라우트 체이닝(route chaining)** 을 위한 문법이지만, 어떤 객체에 연결되느냐로 갈림

---

### 🔹 1. `app.route('/')`

- **Express 애플리케이션의 전역(app) 레벨 라우터**에 직접 라우트 설정
- 즉, **서버 전체에서 해당 경로('/')에 대한 요청** 처리

```js
// app.js
import express from "express";
const app = express();

// app.route('/') : 전역 라우팅
app
  .route("/")
  .get((req, res) => {
    res.send("GET /");
  })
  .post((req, res) => {
    res.send("POST /");
  });
```

📌 **요약**

- `app`은 Express 애플리케이션 인스턴스 (`const app = express()`).
- 전역 경로(`/`)에 대해 요청 메서드별 핸들러 직접 체이닝 가능
- 보통 **메인 엔트리포인트(app.js)**에서 사용

---

### 🔹 2. `express.Router().route('/')`

- **모듈화된 서브 라우터**에서 라우트를 정의할 때 사용
- 즉, `app` 내부의 **하위 라우트 그룹을 관리**

```js
// routes/userRouter.js
import express from "express";
const router = express.Router();

router
  .route("/")
  .get((req, res) => {
    res.send("GET /users");
  })
  .post((req, res) => {
    res.send("POST /users");
  });

export default router;
```

그리고 `app.js`에서 이 라우터를 mount 👇

```js
// app.js
import express from "express";
import userRouter from "./routes/userRouter.js";

const app = express();

app.use("/users", userRouter);
```

이 경우 실제 경로는 `/users/`  
즉, `express.Router().route('/')`는 **라우터 전용의 “로컬 루트(/)”**

---

## 🔸 정리 비교표

| 구분       | `app.route('/')`                   | `express.Router().route('/')`              |
| ---------- | ---------------------------------- | ------------------------------------------ |
| 소속       | Express 앱 인스턴스                | Router 인스턴스                            |
| 사용 위치  | `app.js` 등 최상위 서버 파일       | 모듈화된 `router` 파일                     |
| 실제 경로  | `'/'`                              | `app.use('/prefix', router)`에 따라 달라짐 |
| 역할       | 전역 라우트 정의                   | 특정 경로 그룹 관리 (모듈화)               |
| 주 사용 예 | 루트, 로그인, 건강검사용 라우트 등 | `/users`, `/products` 등 REST API 라우트   |

---

## 🔹 결론

> 🔸 **`app.route()`** → 전역 라우트  
> 🔸 **`express.Router().route()`** → 모듈화된 하위 라우트

## 라우터 레벨 미들웨어

### `app.use()` vs. `router.use()`

- `app.use()` : 앱 레벨 미들웨어로 앱 전체를 대상으로 하는 미들웨어 설정
- `router.use()` : 라우트 레벨 미들웨어로 해당 라우트에 대해서 실행되는 미들웨어 설정

```js
import express from "express";

const app = express();

// ✅ product 관련 라우터 생성
const productRouter = express.Router();

// ✅ 라우트 레벨 미들웨어: productRouter 전체에 적용됨
const authMiddleware = (req, res, next) => {
  console.log("인증 실행");
  next();
};

// ✅ 이 미들웨어는 productRouter 내 모든 경로에서 실행됨
productRouter.use(authMiddleware);

// ✅ /products/ 경로
productRouter
  .route("/")
  .get((req, res) => {
    res.json({ message: "Product 목록 보기" });
  })
  .post((req, res) => {
    res.json({ message: "Product 추가하기" });
  });

// ✅ /products/:id 경로
productRouter
  .route("/:id")
  .patch((req, res) => {
    res.json({ message: "Product 수정하기" });
  })
  .delete((req, res) => {
    res.json({ message: "Product 삭제하기" });
  });

// ✅ /products 경로로 productRouter 등록
app.use("/products", productRouter);

// ✅ user 관련 라우터 (미들웨어 없음)
const userRouter = express.Router();

// ✅ /users/ 경로
userRouter
  .route("/")
  .get((req, res) => {
    res.json({ message: "User 목록 보기" });
  })
  .post((req, res) => {
    res.json({ message: "User 추가하기" });
  });

// ✅ /users 경로로 userRouter 등록
app.use("/users", userRouter);

// ✅ 서버 실행
app.listen(3000, () => {
  console.log("Server is listening on port 3000");
});
```

# 파일 업로드

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 예
- 예

---

## 🚀 내일의 계획

- 예
- 예

---

```

```
