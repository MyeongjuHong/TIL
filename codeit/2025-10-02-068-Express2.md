# 🗓️ 2025-10-02 TIL 68일차

## ✅ 오늘의 성취 (잘한 점)

- 예
- 예

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

### 🔹 주요 개념 정리

### 🔹 예제 코드

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

## 🔹 SWR(Stale-While-Revalidate)란?

원래는 **HTTP 캐싱 전략**에서 나온 개념이에요.

- **Stale (오래된 데이터)**: 캐시된 데이터를 우선적으로 사용해 **빠른 응답**을 제공
- **While Revalidate (백그라운드 갱신)**: 캐시된 데이터를 보여주는 동시에 **백그라운드에서 최신 데이터를 다시 가져옴**

즉, 사용자는 **즉시 캐시 데이터**를 보고, 네트워크 요청은 **비동기적으로 최신화**됩니다.

---

## 🔹 TanStack Query에서의 SWR 동작

TanStack Query는 **캐시와 자동 refetch** 기능을 통해 SWR을 구현합니다.

1. **데이터를 요청할 때**

   - 우선 캐시에 저장된 데이터를 즉시 반환 (stale 상태라도 보여줌).
   - 사용자 경험(UX)이 끊기지 않음.

2. **백그라운드에서 네트워크 요청 실행**

   - 만약 캐시된 데이터가 오래되었거나(`staleTime` 경과)
   - refetch 조건(포커스 전환, 윈도우 리포커스 등)이 충족되면
   - 최신 데이터를 서버에서 가져옴.

3. **갱신 완료 시**

   - 캐시와 UI가 최신 데이터로 자동 업데이트됨.

---

## 🔹 관련 주요 옵션

TanStack Query에서 SWR 동작을 제어하는 주요 옵션은 다음과 같아요:

- **`staleTime`**: 데이터가 “신선(fresh)”하다고 판단되는 시간(ms).

  - 기본값: `0` → 가져오자마자 stale 상태로 간주 (즉시 SWR 동작).
  - 예: `staleTime: 5000` → 5초 동안은 fresh로 간주, 그동안에는 재검증(refetch) 안 함.

- **`cacheTime`**: 캐시가 메모리에 유지되는 시간(ms).

  - 예: `cacheTime: 1000 * 60 * 5` → 5분 동안 캐시 유지.

- **자동 리패치 조건**

  - 윈도우 포커스 시(`refetchOnWindowFocus`)
  - 네트워크 다시 연결 시(`refetchOnReconnect`)
  - 컴포넌트 마운트 시(`refetchOnMount`)

---

## 🔹 예시 흐름

예를 들어 `useQuery`로 데이터를 가져올 때:

1. 사용자가 페이지를 열면 → 캐시된 데이터 먼저 보여줌.
2. 동시에 서버에 새 데이터 요청 시작.
3. 서버에서 응답 오면 → 캐시와 UI 모두 최신화.

즉, **빠른 응답성 + 최신성 보장**이라는 장점이 있어요.

---

👉 정리하면,
**TanStack Query의 SWR은 "캐시 데이터 즉시 제공 + 백그라운드 최신화" 전략으로, staleTime·cacheTime 등 옵션으로 조절할 수 있습니다.**

---

refetch어쩌구저쩌구는 stale 상태가 된 query 객체

QueryCache라는 중앙 저장소

#### invalidate

- **개발자가** 의도적으로 캐시를 stale 상태로 표시
- stale 상태의 쿼리는 화면에서 다시 활성화되거나 자동 refetch 규칙 발동시 자동으로 refetch됨

#### revalidate

- **QueryObserver(TanstackQuery)**가 refetch 트리거
- stale 상태의 쿼리가 자동으로 서버에서 refetch되면서 갱신되는 **과정**
- when
  - 컴포넌트 마운트
  - window focus
  - 네트워크 reconnect
  - 개발자가 refetch() 호출

## enabled, select

### enabled 🌟

- enabled false여도 Tanstack Query는 여전히 그 queryKey 등록하고 관리함
- 단지 queryFn 실행하지 않을 뿐 (= 네트워크 요청XX = fetching XX)
- 캐시된 데이터 있으면 그대로 리턴
  => 이 시점에 서버 요청할지 말지 제어하는 플래그

```jsx
const { data, isFetching } = useQuery({
  queryKey: ["user", userId], // 캐시에 등록됨
  queryFn: fetchUser,
  enabled: !!userId, // userId가 있을 때만 실행
});
```

특정 트리거로 데이터를 fetching하고 싶을 때

1. enabled: false
2. refetch 내장함수를 특정 트리거에 호출

### select

- 받아온 데이터를 가공하고 싶을 때 캐시된 원본 데이터에서 내가 원하는 형태로 변환해 리턴
- 원본 캐시 그대로, 반환만 가공

```jsx
const { data } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  select: (data) => data.map((todo) => todo.title), // title 목록만 반환
});
```

---


# Express



## 미들웨어

## 라우터;


```json
{
  "name": "topic-express-essential",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "express": "^5.1.0"
  }
}
```

익스프레스는 모든 것이 미들웨어로 이루어져있다?
미들웨어는 콜백 함수다?
근데 왜 미들웨어라고 하지? 명명 이유가 궁금따

pathparams는 req.params로
queryparams는 req.query로
body는 req.body로

app.use()는 path가 없으면 GPPD 뭐든 들어와도 되니까 전역적인거고
path 있으면 해당 경로로 시작할 때 실행할거로 하는거라 부분 전역적인거임

app.all()은 경로가 딱 매칭될때만


// NOTE: res 줄 땐 return 명시할 것!!

// NOTE: filter 대신 find 사용
// NOTE: params.id는 문자열, user.id는 숫자 => 동등연산자보단 일치연산자 === 사용 위해 params.id를 숫자로 형변환 시켜야함
// NOTE: res 받는 시점에 형변환 시켜야 함!!

// NOTE: 강사님이 피로 새긴 유서 = 유효성 검사는.. 빡빡할수록 good....

// NOTE: 4xx는 클 문제, 5xx는 서버 문제
// NOTE: 에러코드 미리 정의해놓기 CODE_NOT_FOUND=E0123B

// 미들웨어 중요 개념 - 통과
// 미들웨어는 하나하나 통과하는거다
// next로 다음으로 간다



</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 예
- 예

---

## 🚀 내일의 계획

- 예
- 예

---
