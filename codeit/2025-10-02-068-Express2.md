# 🗓️ 2025-10-02 TIL 68일차

## ✅ 오늘의 성취 (잘한 점)

- 예
- 예

---

## 📚 오늘의 학습 (배운 점)

> ### [학습목표]
>
> 1. Express의 기본 개념을 알고, 실행환경을 구성할 수 있다.
> 2. 미들웨어의 역할과 구조를 이해하고, 요청/응답 객체를 다룰 수 있다.

- Express
- 미들웨어
  - 미들웨어란?
  - 미들웨어 구조
    - req 속성 3가지
    - 미들웨어 매개변수 2개
    - 미들웨어 매개변수 3개
    - 미들웨어 매개변수 4개
  - 미들웨어 사용법
    - 미들웨어 재사용

### 🔹 핵심 주제

### 🔹 주요 개념 정리

### 🔹 예제 코드

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

## 🔹 SWR(Stale-While-Revalidate)란?

원래는 **HTTP 캐싱 전략**에서 나온 개념이에요.

- **Stale (오래된 데이터)**: 캐시된 데이터를 우선적으로 사용해 **빠른 응답**을 제공
- **While Revalidate (백그라운드 갱신)**: 캐시된 데이터를 보여주는 동시에 **백그라운드에서 최신 데이터를 다시 가져옴**

즉, 사용자는 **즉시 캐시 데이터**를 보고, 네트워크 요청은 **비동기적으로 최신화**됩니다.

---

## 🔹 TanStack Query에서의 SWR 동작

TanStack Query는 **캐시와 자동 refetch** 기능을 통해 SWR을 구현합니다.

1. **데이터를 요청할 때**

   - 우선 캐시에 저장된 데이터를 즉시 반환 (stale 상태라도 보여줌).
   - 사용자 경험(UX)이 끊기지 않음.

2. **백그라운드에서 네트워크 요청 실행**

   - 만약 캐시된 데이터가 오래되었거나(`staleTime` 경과)
   - refetch 조건(포커스 전환, 윈도우 리포커스 등)이 충족되면
   - 최신 데이터를 서버에서 가져옴.

3. **갱신 완료 시**

   - 캐시와 UI가 최신 데이터로 자동 업데이트됨.

---

## 🔹 관련 주요 옵션

TanStack Query에서 SWR 동작을 제어하는 주요 옵션은 다음과 같아요:

- **`staleTime`**: 데이터가 “신선(fresh)”하다고 판단되는 시간(ms).

  - 기본값: `0` → 가져오자마자 stale 상태로 간주 (즉시 SWR 동작).
  - 예: `staleTime: 5000` → 5초 동안은 fresh로 간주, 그동안에는 재검증(refetch) 안 함.

- **`cacheTime`**: 캐시가 메모리에 유지되는 시간(ms).

  - 예: `cacheTime: 1000 * 60 * 5` → 5분 동안 캐시 유지.

- **자동 리패치 조건**

  - 윈도우 포커스 시(`refetchOnWindowFocus`)
  - 네트워크 다시 연결 시(`refetchOnReconnect`)
  - 컴포넌트 마운트 시(`refetchOnMount`)

---

## 🔹 예시 흐름

예를 들어 `useQuery`로 데이터를 가져올 때:

1. 사용자가 페이지를 열면 → 캐시된 데이터 먼저 보여줌.
2. 동시에 서버에 새 데이터 요청 시작.
3. 서버에서 응답 오면 → 캐시와 UI 모두 최신화.

즉, **빠른 응답성 + 최신성 보장**이라는 장점이 있어요.

---

👉 정리하면,
**TanStack Query의 SWR은 "캐시 데이터 즉시 제공 + 백그라운드 최신화" 전략으로, staleTime·cacheTime 등 옵션으로 조절할 수 있습니다.**

---

refetch어쩌구저쩌구는 stale 상태가 된 query 객체

QueryCache라는 중앙 저장소

#### invalidate

- **개발자가** 의도적으로 캐시를 stale 상태로 표시
- stale 상태의 쿼리는 화면에서 다시 활성화되거나 자동 refetch 규칙 발동시 자동으로 refetch됨

#### revalidate

- **QueryObserver(TanstackQuery)**가 refetch 트리거
- stale 상태의 쿼리가 자동으로 서버에서 refetch되면서 갱신되는 **과정**
- when
  - 컴포넌트 마운트
  - window focus
  - 네트워크 reconnect
  - 개발자가 refetch() 호출

## enabled, select

### enabled 🌟

- enabled false여도 Tanstack Query는 여전히 그 queryKey 등록하고 관리함
- 단지 queryFn 실행하지 않을 뿐 (= 네트워크 요청XX = fetching XX)
- 캐시된 데이터 있으면 그대로 리턴
  => 이 시점에 서버 요청할지 말지 제어하는 플래그

```jsx
const { data, isFetching } = useQuery({
  queryKey: ["user", userId], // 캐시에 등록됨
  queryFn: fetchUser,
  enabled: !!userId, // userId가 있을 때만 실행
});
```

특정 트리거로 데이터를 fetching하고 싶을 때

1. enabled: false
2. refetch 내장함수를 특정 트리거에 호출

### select

- 받아온 데이터를 가공하고 싶을 때 캐시된 원본 데이터에서 내가 원하는 형태로 변환해 리턴
- 원본 캐시 그대로, 반환만 가공

```jsx
const { data } = useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  select: (data) => data.map((todo) => todo.title), // title 목록만 반환
});
```

---

# Express

| 구분                 | 미들웨어 (Middleware)                                      | 라우트 핸들러 (Route Handler)                                           |
| -------------------- | ---------------------------------------------------------- | ----------------------------------------------------------------------- |
| **역할**             | 요청(Request)과 응답(Response) 사이에서 **중간 처리** 수행 | 특정 경로(`path`)와 메서드(`GET`, `POST`, 등)에 대해 **최종 응답 처리** |
| **등록 방식**        | `app.use()` 또는 `app.METHOD()`                            | `app.METHOD()`                                                          |
| **next() 호출 여부** | `next()`를 호출해 다음 미들웨어나 라우트로 제어를 넘김     | 일반적으로 마지막이라 `next()`를 호출하지 않음                          |
| **사용 예시**        | 로깅, 인증, 에러 처리, JSON 파싱 등                        | `/users`, `/login` 등 실제 응답 반환                                    |
| **응답 종료 여부**   | 대체로 응답을 직접 보내지 않음 (`res.send()` 거의 없음)    | 응답을 보냄 (`res.send()`, `res.json()`, `res.render()` 등)             |

## 미들웨어

## 라우터

```jsx
const express = require("express");
const app = express();

/* ✅ (1) 이 함수는 '미들웨어' */
function checkAuth(req, res, next) {
  const isLoggedIn = true; // 로그인 여부 예시 (실제론 세션/토큰 확인)
  if (isLoggedIn) {
    console.log("인증 통과 ✅");
    next(); // 다음 단계로 진행
  } else {
    res.status(401).send("인증 필요 ❌");
  }
}

/* ✅ (2) 이 함수는 '라우트 핸들러' */
function getProfile(req, res) {
  res.send("사용자 프로필 페이지입니다 🧑‍💻");
}

/* ✅ (3) 라우트 정의: 미들웨어 + 핸들러 조합 */
app.get("/profile", checkAuth, getProfile);

/* ✅ (4) 다중 미들웨어도 가능 */
app.get(
  "/dashboard",
  (req, res, next) => {
    console.log("대시보드 접근 로그 기록");
    next();
  },
  checkAuth,
  (req, res) => {
    res.send("대시보드 페이지입니다 📊");
  }
);

app.listen(3000, () => console.log("Server running on port 3000"));
```

---

```json
{
  "name": "topic-express-essential",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "express": "^5.1.0"
  }
}
```

익스프레스는 모든 것이 미들웨어로 이루어져있다?
미들웨어는 콜백 함수다?
근데 왜 미들웨어라고 하지? 명명 이유가 궁금따

pathparams는 req.params로
queryparams는 req.query로
body는 req.body로

app.use()는 path가 없으면 GPPD 뭐든 들어와도 되니까 전역적인거고
path 있으면 해당 경로로 시작할 때 실행할거로 하는거라 부분 전역적인거임

app.all()은 경로가 딱 매칭될때만

// NOTE: res 줄 땐 return 명시할 것!!

// NOTE: filter 대신 find 사용
// NOTE: params.id는 문자열, user.id는 숫자 => 동등연산자보단 일치연산자 === 사용 위해 params.id를 숫자로 형변환 시켜야함
// NOTE: res 받는 시점에 형변환 시켜야 함!!

// NOTE: 강사님이 피로 새긴 유서 = 유효성 검사는.. 빡빡할수록 good....

// NOTE: 4xx는 클 문제, 5xx는 서버 문제
// NOTE: 에러코드 미리 정의해놓기 CODE_NOT_FOUND=E0123B

// 미들웨어 중요 개념 - 통과
// 미들웨어는 하나하나 통과하는거다
// next로 다음으로 간다

> 중간 미들웨어 ⇒ next() 호출 (흐름 pass)
> 최종 라우트핸들러 ⇒ res.send등으로 응답 종료

| 구분           | `app.use()`                               | `app.get()                     |
| -------------- | ----------------------------------------- | ------------------------------ |
| 실행 시점      | 요청 메서드 무관 (GET, POST, PUT 등 모두) | 해당 HTTP 메서드에만 실행      |
| 경로 매칭 방식 | `path`로 시작하는 모든 하위 경로 포함     | 경로 **정확히 일치해야 함**    |
| 주 용도        | 공통 로직 (로깅, 인증, 에러처리 등)       | 실제 응답 처리 (라우트 핸들러) |

### 미들웨어 재사용

> Router()를 사용하지 않아도, app.all()은 `라우트 레벨 미들웨어`
> ⇒ Router 인스턴스 사용했는지는 중요XX, 라우트 핸들러 사용했는지가 중요
> ⇒ 근데 결국은 똑같다 !

```[app] ← Router 기능 포함
 ├─ app.use(...)       // 앱 레벨
 ├─ app.get('/users')  // 라우트 레벨
 ├─ app.post('/users') // 라우트 레벨
 └─ router('/api')     // 모듈화 라우터
       ├─ router.get(...)
       └─ router.post(...)
```

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 예
- 예

---

## 🚀 내일의 계획

- 예
- 예

---
