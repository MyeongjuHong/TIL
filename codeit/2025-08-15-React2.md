# 🗓️ 2025-08-15 TIL

## ✅ 오늘의 성취 (잘한 점)

- 야호 마침내 React 끝... 힘들고 길었다
- TIL도 맞춰서 딱 끝!

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

- **React Context를 활용한 전역 상태 관리와 실행 흐름**
- props drilling 문제 해결
- Context.Provider + useContext + Custom Hook 패턴

---

### 🔹 주요 개념 정리

1. **prop drilling 문제**

   - 여러 단계에 걸쳐 props 전달 필요 → 코드 복잡

2. **Context 사용 목적**

   - 전역 데이터 공유 가능
   - Provider → 하위 컴포넌트에서 useContext로 접근

3. **Custom Hook 활용**

   - `useLocale`, `useSetLocale` 등으로 Context 접근 코드 분리
   - Provider 감싸지 않으면 에러 발생 → 안전한 코드

4. **실행 순서**

   - 사용자 옵션 변경 → onChange 이벤트 발생
   - handleChange 함수 실행 → setLocale 호출
   - useState 상태 변경 예약 → App 컴포넌트 재렌더링
   - Context.Provider value 및 props 업데이트
   - LocaleSelect 및 다른 구독 컴포넌트 재렌더링 → UI 동기화

---

### 🔹 예제 코드

**LocaleContext.js**

```jsx
import { createContext, useState, useContext } from "react";

const LocaleContext = createContext();

export function LocaleProvider({ defaultValue = "ko", children }) {
  const [locale, setLocale] = useState(defaultValue);
  return (
    <LocaleContext.Provider value={{ locale, setLocale }}>
      {children}
    </LocaleContext.Provider>
  );
}

export function useLocale() {
  const context = useContext(LocaleContext);
  if (!context) throw new Error("Provider 필요");
  return context.locale;
}

export function useSetLocale() {
  const context = useContext(LocaleContext);
  if (!context) throw new Error("Provider 필요");
  return context.setLocale;
}
```

**App.js**

```jsx
function App() {
  return (
    <LocaleProvider defaultValue="ko">
      <LocaleSelect />
    </LocaleProvider>
  );
}
```

**LocaleSelect.js**

```jsx
function LocaleSelect() {
  const locale = useLocale();
  const setLocale = useSetLocale();

  const handleChange = (e) => setLocale(e.target.value);

  return (
    <select value={locale} onChange={handleChange}>
      <option value="ko">한국어</option>
      <option value="en">English</option>
    </select>
  );
}
```

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

# React 데이터 다루기

## 전역 데이터 다루기 - context (상황에 대한 정보)

전역 데이터 다룰 때 state와 prop만 사용 시 props로 여러 번, 여러 곳에 내려줘야 하는 문제점 발생

### prop drilling

- 상위 컴포넌트에서 하위 컴포넌트로 반복적인 prop 전달 상황

### context 사용 효과

- 여러 컴포넌트에서 사용하는 데이터 공유 가능
- 반복적인 prop 전달(prop drilling) 불필요
- 주변 상황에 대한 정보 공유

### Context.Provider 컴포넌트

- 데이터 공유 범위 지정
- Provider의 자손 컴포넌트에서 props를 거치지 않고 데이터 사용 가능

### context 사용 단계

1. `const 컨텍스트명 = createContext();`
2. 사용할 컴포넌트에 `<컨텍스트명.Provider>` 감싸기

   - 공유하고 싶은 value props 지정 가능

3. `const 변수명 = useContext(컨텍스트명);`

   - useContext로 해당 컨텍스트의 value 접근 및 할당

4. 이 변수를 화면에 렌더링

⚠️ 전역 공유되더라도 import 필수

---

## 코드 예시

### App.js

1. `const [locale, setLocale] = useState('ko');`
2. `<LocaleContext.Provider value={locale}>`
3. `<LocaleSelect value={locale} onChange={setLocale} />`

### LocaleSelect.js

- `{ value, onChange }`

1. `const handleChange = (e) => onChange(e.target.value);`
2. `<select value={value} onChange={handleChange}>`
3. `<option value=‘ko’> / <option value=‘en’>`

<details><summary>실행 순서</summary>

### `<select>` 옵션 변경 시 코드 실행 흐름

1. **사용자의 동작 발생**

   - 사용자가 LocaleSelect.js 컴포넌트의 `<select>` 태그에서 옵션을 변경
   - 예: 'ko' → 'en' 선택

2. **onChange 이벤트 발생**

   - `<select>` 태그에 등록된 `onChange={handleChange}` 실행
   - 이벤트 객체 `e` 전달됨
   - `e.target.value`에는 사용자가 선택한 값('en') 저장

3. **handleChange 함수 실행**

   - LocaleSelect.js 내부의 `handleChange` 실행
   - 코드:

     ```js
     const handleChange = (e) => onChange(e.target.value);
     ```

   - 이때 `onChange`는 App.js에서 LocaleSelect로 내려준 `setLocale` 함수

4. **setLocale 함수 실행**

   - `setLocale('en')` 실행
   - App.js에서 선언한 `const [locale, setLocale] = useState('ko')`의 상태 변경
   - 기존 locale 값 'ko' → 새로운 값 'en'으로 업데이트 예약

5. **React 상태 업데이트 처리**

   - React의 `useState` 훅 동작
   - `setLocale` 실행 직후 즉시 값이 바뀌는 것이 아니라, **다음 렌더링 사이클에서 반영**
   - React는 해당 state가 속한 컴포넌트(App 컴포넌트)를 재렌더링 예약

6. **App 컴포넌트 재렌더링**

   - React가 App 컴포넌트를 다시 실행
   - 이때 `locale`의 최신 값이 'en'으로 반영됨

7. **Context와 Props 값 업데이트**

   - App 컴포넌트 재렌더링 시 두 부분 동작

     1. `<LocaleContext.Provider value={locale}>`

        - value가 `'en'`으로 변경
        - 이 Provider를 구독하는 모든 하위 컴포넌트가 새로운 value 받음

     2. `<LocaleSelect value={locale} onChange={setLocale} />`

        - LocaleSelect의 `value` prop도 `'en'`으로 변경되어 전달

8. **LocaleSelect.js 재렌더링**

   - LocaleSelect 컴포넌트 재실행
   - props로 받은 `value='en'` 적용
   - `<select value="en">` 렌더링
   - 화면에서 드롭다운의 선택 값이 'en'으로 표시

9. **Context를 사용하는 다른 컴포넌트 동기화**

   - LocaleSelect뿐 아니라, LocaleContext를 구독(useContext, useLocale 등)하는 다른 컴포넌트들도 재렌더링
   - 모두 최신 locale 값('en')을 사용 가능

10. **최종 결과**

    - 사용자의 작은 선택(옵션 변경)
    - → onChange 이벤트 발생
    - → handleChange 실행
    - → setState 함수 호출
    - → 상태 변경 예약
    - → App 및 하위 컴포넌트 재렌더링
    - → Context value 및 props 업데이트
    - → 화면 UI 동기화
    - **결과적으로 애플리케이션 전체 상태가 일관되게 업데이트**

</details>

---

## 상태 관리와 Context 분리 문제

- 상태 관리 컴포넌트(직접 참조한 컨텍스트) 제외 후 Provider 이동 시 오류 발생
- 해결: locale state와 Context 한 곳에서 관리

---

## Context + Provider + Custom Hook 사용

### LocaleContext.js

```jsx
import { createContext } from "react";

const LocaleContext = createContext();

export function LocaleProvider({ defaultValue = "ko", children }) {
  const [locale, setLocale] = useState(defaultValue);
  return (
    <LocaleContext.Provider value={{ locale, setLocale }}>
      {children}
    </LocaleContext.Provider>
  );
}

export function useLocale() {
  const context = useContext(LocaleContext);
  if (!context) {
    throw new Error("error");
  }
  return context.locale;
}

export function useSetLocale() {
  const context = useContext(LocaleContext);
  if (!context) {
    throw new Error("error");
  }
  return context.setLocale;
}
```

### App.js

```jsx
<LocaleContext.Provider value={locale}>
<LocaleProvider defaultValue={'ko'}>
  <LocalSelect />
</LocaleProvider>
```

### ReviewList.js

```jsx
const locale = useContext(LocaleContext);
const locale = useLocale();
```

### LocaleSelect.js

```jsx
function LocaleSelect() {
  const locale = useLocale();
  const setLocale = useSetLocale();
  const handleChange = (e) => setLocale(e.target.value);
  return <select value={locale} onChange={handleChange}></select>;
}
```

---

## 실행 순서 (커스텀 Hook 적용 후)

<details><summary>실행 순서</summary>

1. **초기 렌더링 시작**

   - App.js 실행 → `<LocaleProvider>` 호출
   - useState('ko') 실행 → locale='ko' 초기화
   - `<LocaleContext.Provider value={{ locale: 'ko', setLocale }}>` 실행
   - children `<LocaleSelect />` 렌더링

2. **LocaleSelect.js 실행**

   - useLocale() 호출 → context.locale 반환 → locale='ko'
   - useSetLocale() 호출 → context.setLocale 반환
   - `<select value="ko">` 렌더링

3. **사용자 입력 발생**

   - 'ko' → 'en' 선택
   - onChange 이벤트 발생 → handleChange 실행 → setLocale('en') 호출

4. **상태 변경 및 재렌더링**

   - locale 상태 'en'으로 변경
   - LocaleProvider 재렌더링 → value 업데이트
   - 하위 컴포넌트 재렌더링

5. **재렌더링 완료**

   - useLocale() → 'en' 반환
   - `<select value="en">` 업데이트

➡️ 작은 동작 하나가 전체 애플리케이션 상태 업데이트 및 동기화

</details>

---

## 실습 단계

1. **LocaleContext.js**

   - LocaleContext 생성
   - LocaleProvider 생성 (state 포함)
   - useLocale, useSetLocale 커스텀 Hook 생성

2. **useTranslate.js**

   - 사전 생성
   - key → 언어 문자열 리턴 Hook 생성

3. **LocaleSelect.js**

   - 커스텀 Hook으로 locale, setLocale 사용
   - select JSX 작성 (value, onChange 지정)

4. **App.js**

   - Context.Provider → LocaleProvider 변경
   - `<LocaleSelect />` 추가

5. **FoodList.js / FoodListItem.js**

   - `const t = useTranslate();`
   - `{t('키이름')}` 출력

---

## 주의사항

- hook은 일반 함수 내부(handleChange 등)에서 호출 불가
- Provider 역할 컴포넌트에서 state 생성 후 value로 전달
- useContext 기반 커스텀 hook 사용 시 반드시 해당 Provider 감싸야 안전

---

## React 상태 관리 도구 비교

| 도구                  | 주요 역할                   | 적합한 상황                                       | 특징                                                |
| --------------------- | --------------------------- | ------------------------------------------------- | --------------------------------------------------- |
| **Context**           | 간단한 클라이언트 상태 공유 | 다크 모드, 로그인 상태 등 자주 변하지 않는 데이터 | React 내장 기능, 설치 불필요, 학습 난이도 가장 낮음 |
| **Flux**              | 단방향 데이터 흐름 패턴     | Redux 기반 개념                                   | 라이브러리 아님, 데이터 흐름 명확화                 |
| **Redux**             | 복잡한 클라이언트 상태 관리 | 대규모 앱 상태 관리                               | Store, Reducer 등 규칙 엄격, 디버깅 용이            |
| **Zustand & Recoil**  | 가볍고 쉬운 상태 관리       | Redux보다 간단한 관리 필요 시                     | 보일러플레이트 적음, 성능 우수                      |
| **React Query & SWR** | 효율적인 서버 상태 관리     | API 데이터 통신, 캐싱, 동기화 상황                | 서버 상태 자동화, 클라이언트 상태 관리 X            |

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 말이 TIL이지 공부 정리용이다보니 자꾸 단위별로 TIL을 쓰게 되어서 하루 이틀을 거르고 커밋하게 된다ㅠㅠ 그래도 프로젝트 동안에는 TIL 꼬박꼬박 쓸 수 있을 듯!
- 느려..! 그래도 얼추 과로하면 커버가 될 정도로 따라잡음

---

## 🚀 내일의 계획

- Router 완강
- CS 스터디 과제

---
