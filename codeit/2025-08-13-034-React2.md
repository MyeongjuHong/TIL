# 🗓️ 2025-08-13 TIL 34일차

## ✅ 오늘의 성취 (잘한 점)

- React 입력 폼 다루기 완!
- 정리도 완~~

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

React에서 입력 폼과 파일 인풋을 관리하는 방법, 제어/비제어 컴포넌트, state lifting, ref와 useEffect 활용

### 🔹 주요 개념 정리

- **제어 컴포넌트**: React state가 input value를 제어
- **비제어 컴포넌트**: input value를 React가 직접 제어하지 않음
- **state lifting**: 여러 컴포넌트가 공유하는 state를 공통 부모로 올림
- **ref**: 실제 DOM 노드에 접근해 value 초기화 가능
- **useEffect**: React 외부 상태/SideEffect 동기화 및 정리(cleanup)

### 🔹 예제 코드

```jsx
// 제어 컴포넌트 input
const [value, setValue] = useState('');
<input value={value} onChange={(e) => setValue(e.target.value)} />

// 비제어 컴포넌트 file input
const inputRef = useRef();
<input type="file" ref={inputRef} />
<button onClick={() => inputRef.current.value = ''}>초기화</button>

// useEffect cleanup
useEffect(() => {
  const id = setInterval(() => console.log('tick'), 1000);
  return () => clearInterval(id);
}, []);
```

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

# React 데이터 다루기

## 입력 폼 다루기

### input

state 값과 input의 값을 동일하게 만드는 것이 핵심!

리액트에서는 input value가 달라질 때마다 onChange 이벤트가 발생  
(HTML의 onInput 이벤트와 동일한 동작).

1. input value 반영용 state 생성
2. 값 변경할 때마다 setState로 변경
3. onChange prop에 해당 변경 함수 설정

=> value prop으로 스테이트 값을 내려주고, onChange prop으로 핸들러 함수를 넘겨주기

### form

HTML form 태그는 기본적으로 submit 버튼을 눌렀을 때 입력 폼의 값과 함께 GET 리퀘스트를 전송  
=> `e.preventDefault()`로 막기

입력 폼에서 여러 개로 관리하던 state를 input 태그의 name 값을 활용해 이벤트 객체에서 name 값을 가져와 객체로 할당

```jsx
const [values, setValues] = useState({
  title: "",
  rating: 0,
  content: "",
  // 초기값 설정
});

const handleChange = (e) => {
  const { name, value } = e.target;
  setValues((prevValues) => ({
    // 객체 return 대신 소괄호 사용
    ...prevValues,
    [name]: value, // 계산된 속성명
    // e.target.name: e.target.name >> 오류!!
    // 객체 리터럴에서 key는 e.target.name을 문자 그대로로 인식
    // e.target.name은 변수명 아닌 ‘객체 접근 표현식’
    // 그래서 미리 구조분해 할당한 name을 동적으로 지정
  }));
};
```

=> 이벤트 객체의 target.name과 target.value 값 사용해 객체형 스테이트 하나만으로 값 처리

### 제어 컴포넌트 / 비제어 컴포넌트

1. 제어 컴포넌트

   - 리액트를 통해 input 값을 지정하고 제어
   - state 값이 input의 value prop으로 내려가 입력에 상관없이 리액트 state와 동일한 값으로 지정
   - input value와 onChange 핸들러 사용 시 input 값 제어
   - input에서 value 속성을 state값/prop으로 할당할 때
   - 리액트에서 사용하는 값과 실제 input 값이 항상 일치

2. 비제어 컴포넌트

   - value 값을 지정하지 않는 컴포넌트
   - 리액트에서 실제 input 값을 제어하지 않음

```jsx
const handleSubmit = (e) => {
  e.preventDefault();
  const form = e.target;
  const formData = new FormData(form);
  // ...
};
// form 태그로 곧바로 FormData 생성 가능
```

### 파일 인풋

파일 인풋은 반드시 비제어 input으로 생성해야 함
fileInput에서 value는 파일 이름을 받는데 JS는 빈 문자열로만 설정 가능  
=> 보안 이슈로 HTML에서 file input은 사용자만 값 변경 가능

1. input type="file" 클릭 시 OS 단에서 업로드 창 open

   - 브라우저가 아닌 OS에서 띄우는 창 → JS / 웹페이지는 안에 보기 불가능

2. 업로드
3. 브라우저가 해당 파일의 메타데이터(파일명, 타입, 크기)를 input.files에 저장

   - 이때 JS는 fileInput.files를 통해 File 객체 얻기 가능, 실제 파일 경로는 파악 불가능

#### \* JavaScript가 할 수 있는 것

- fileInput.files\[0]로 File 객체 가져오기

  - FileReader API로 내용 읽어서 처리 가능 (예: 미리보기)
  - fetch나 FormData를 사용해 서버로 전송 가능

- JS가 value를 바꿔서 새로운 파일 지정 불가능

  - `fileInput.value = "something.txt"` → 무시됨
  - `fileInput.value = ""` → 선택 취소만 가능

#### \* 사용자가 업로드 버튼을 누르는 순간

- 브라우저는 내부 메모리에 있는 파일 내용을 multipart/form-data 형식으로 변환
- `<form>`의 action 주소로 HTTP POST 요청 전송
- 서버는 요청 받아 파일 저장 또는 처리
  보안을 위해 브라우저가 사용자 파일 경로 숨김 (`C:\fakepath\파일명.확장자`)
  FileInput은 value prop 지정 불가능 → 비제어 컴포넌트로 만들기

#### \* 비제어 컴포넌트인 FileInput 다루기

FileInput 컴포넌트에서 state 대신 props 사용해 다른 속성 전달하도록 수정 (state lifting)

<details>
<summary>리액트적 사고, state lifting 사고하기</summary>

1. 개념 정리
   state lifting:
2. 두 개 이상의 컴포넌트가 같은 데이터를 필요로 할 때
3. 데이터를 공통 부모 컴포넌트로 올리기
4. 필요한 자식들에게 props로 내려주기

- 포인트: 데이터의 소유자(owner)를 “가장 가까운 공통 부모”로 맞춤

2. 헷갈릴 때 질문

3. 이 데이터를 누가 갖고 있어야 하는가?

4. 이 데이터를 바꾸는 건 누가 할 것인가?

5. 그 데이터를 쓰는 모든 컴포넌트가 공통으로 가지는 부모는 누구인가?

6. 연습 방법

- 🐣 레벨 1: 입력창 2개, 한쪽 입력하면 다른쪽에도 반영

  - 상태는 부모에서 관리, 양쪽 인풋에 props 전달

- 🐥 레벨 2: 다른 컴포넌트끼리 상태 공유

  - A 버튼 클릭 → B 색상 변경
  - 상태는 부모가 관리, A 이벤트 → 부모 state 변경 → B props 전달

- 🐔 레벨 3: 여러 단계 props 내려주기

  - 최상위 state를 2\~3단계 아래 자식까지 내려주기
  - props drilling 체감

4. 습관 팁

- 데이터 출처 찾기 → 어디서 생기는지 확인
- state 최소 범위에만 두기 → 너무 높으면 불필요 렌더링
- 헷갈리면 “부모가 관리, 자식은 보여주기만” 적용

5. React식 사고 루틴

- 하루 10\~20분씩 state 공유 예제 12개 실습
- 같은 문제 두 방식으로 풀어보기: 자식 관리 vs 부모 관리
- 차이점 코드 비교하며 주석 달기
- 자주 쓰는 패턴 스니펫 저장

🐣 레벨 1 — 기초 상태 공유

- 문제: `<InputA />`와 `<InputB />` 두 개의 인풋, 한쪽 입력하면 다른쪽에도 반영
- 힌트: 상태는 공통 부모, value와 onChange를 props로 전달

🐥 레벨 2 — 상태 전달 + 이벤트 반영

- 문제: `<CounterDisplay />`와 `<CounterButtons />`
- 버튼 클릭하면 숫자 즉시 변경, `<CounterDisplay />` 반영
- 힌트: 숫자 상태는 부모, CounterButtons는 부모 함수 호출

🐔 레벨 3 — 서로 다른 데이터 교환

- 문제: `<ColorPicker />`와 `<Box />`
- ColorPicker 색 선택 → Box 배경색 변경, 다른 곳에서도 재사용 가능
- 힌트: 선택한 색 상태는 부모, 부모가 props로 내려주고 setColor 실행

📝 추가 연습 아이디어

- 쇼핑몰 장바구니: 상품 리스트와 장바구니 상태 공유
- 로그인 상태: 헤더(UserInfo)와 메인 페이지 동일 정보
- 체크박스 그룹: 하나 체크 → 나머지 해제 (라디오버튼처럼)

</details>

FileInput state를 props로 바꾸고 컴포넌트 state를 props로 내려주기

1. `FileInput.js`

```jsx
function FileInput({ name, value, onChange }) {
  const handleChange = (e) => {
    const nextValue = e.target.files[0];
    onChange(name, nextValue);
  };
  return <input type="file" onChange={handleChange} />;
}
```

2. 부모 컴포넌트

```jsx
// 1. state에 imgFile 추가
const [values, setValues] = useState({ imgFile: null });

// 2. 변경 함수
const handleChange = (name, value) => {
  setValues((prevValues) => ({
    ...prevValues,
    [name]: value,
  }));
};

// 3. input change 핸들러
const handleInputChange = (e) => {
  const { name, value } = e.target;
  handleChange(name, value);
};

// 4. FileInput 사용
<FileInput name="imgFile" value={values.imgFile} onChange={handleChange} />;
```

#### ref prop로 파일 초기화

- 실제 DOM 노드 접근 위해 사용
- ref 객체로 DOM 노드 참조 가능
- 렌더링 후 생성 → `ref.current` 값 존재, 조건부 렌더링 시 값 없음
- React state로 input type="file" value 직접 설정 불가
  → 보안 때문에 브라우저 막음
- DOM 노드에는 value 존재 → ref로 접근 가능, 읽거나 ""로 초기화 가능

```jsx
const inputRef = useRef();
const handleClearClick = () => {
  const inputNode = inputRef.current; // 노드
  if (!inputNode) return;
  inputNode.value = ""; // DOM input 자체 초기화
  onChange(name, null); // 부모 state 초기화
};

<input type="file" onChange={handleChange} ref={inputRef} />;
{
  value && <button onClick={handleClearClick}>X</button>;
}
```

DOM 노드로 value 접근 가능 (변경은 불가, ''은 가능)

| 접근 방식       | 읽기                | 쓰기        | 실제 경로           |
| --------------- | ------------------- | ----------- | ------------------- |
| input.value     | fakepath 출력       | ""로 초기화 | 실제 경로 숨김      |
| input.files\[0] | 파일 객체 접근 가능 | -           | 파일 내용 접근 가능 |

#### 미리보기

```jsx
const [preview, setPreview] = useState();
useEffect(() => {
  if (!value) return;
  const nextPreview = URL.createObjectURL(value);
  setPreview(nextPreview);
}, [value]);

<img src={preview} alt="이미지 미리보기" />;
```

- 컴포넌트 렌더링 중 React 외부 상태 변경 → SideEffect

#### SideEffect 예시

| 외부 상태/영역                          | SideEffect 여부 |
| --------------------------------------- | --------------- |
| DOM 요소 직접 조작                      | ✅              |
| 브라우저 API 호출 (localStorage, fetch) | ✅              |
| setTimeout, setInterval                 | ✅              |
| console.log 출력                        | ✅              |
| React state 변경 (setState)             | ❌              |
| props 읽기                              | ❌              |

- fetch: 브라우저 상태 변경 → 네트워크 요청, 응답 활용
- SideEffect 다룰 때 useEffect 사용

#### Cleanup Function

```jsx
useEffect(() => {
  // 사이드 이펙트

  return () => {
    // 사이드 이펙트 정리
  }
}, [dep1, dep2, dep3, ...]);
```

- 메모리 낭비 방지 위해 이전 메모리 해제

```jsx
useEffect(() => {
  if (!value) return;
  const nextPreview = URL.createObjectURL(value);
  setPreview(nextPreview);
  return () => {
    setPreview();
    URL.revokeObjectURL(nextPreview); // 메모리 해제
  };
}, [value]);
```

> 렌더링  
> → 화면 반영  
> → useEffect 실행
> (setState / deps 변경)  
> → cleanup 실행  
> → 렌더링  
> → 화면 반영  
> → useEffect 실행  
> → 반복

#### useEffect 요약

- React 외부 데이터/상태 변경 시 사용
- 동기화 목적: React state ↔ 외부 상태 일치
- 내부 state 변화 맞춰 자동 동기화 필요 시

🔹 useEffect 사용하는 경우

- document.title, localStorage, window 이벤트
- setInterval, setTimeout
- 웹소켓/데이터 구독 해제
- state 변경 시 외부 값 변경 필요

🔹 이벤트 핸들러에서 처리 가능 경우

- 단발성 작업: 버튼 클릭 alert, DOM API 호출
- 지속적 동기화 필요 없는 경우

예시: 타이머

```jsx
useEffect(() => {
  const timerId = setInterval(() => {
    console.log("타이머 실행중 ... ");
    setSecond((prevSecond) => prevSecond + 1);
  }, 1000);
  console.log("타이머 시작 🏁");

  return () => {
    clearInterval(timerId);
    console.log("타이머 멈춤 ✋");
  };
}, []);
```

#### props 유무에 따른 함수 렌더링

```jsx
const handleClick = onSelect ? () => onSelect(rating) : undefined;
// onSelect prop이 존재할 때만 실행
<span onClick={handleClick} onMouseOver={handleMouseOver}>
  별
</span>;
```

1. input 태그에 onChange prop 사용 → 입력 시 핸들러 실행
2. 비제어 컴포넌트 → input value를 React가 지정하지 않음
3. form 태그에 onSubmit prop 사용 → submit 버튼 클릭 시 핸들러 실행

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 느려..! 그래도 화이팅이야~~
- 리액트적 사고가 너무너무너무너무너무 어렵다.. 근데 이건 작업하다보면 잡힐 것 같은 느낌~~

---

## 🚀 내일의 계획

- 데이터 보내기 완강
- 전역 데이터 다루기 완강

---
