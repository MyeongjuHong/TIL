# 🗓️ 2025-10-27 TIL 79일차

## ✅ 오늘의 진행 (완료한 작업)

- Prisma 문법을 처음 접하고, 실제 카드 목록 조회 함수 작성
- 조건부 객체 확장(...(조건 && {...}))으로 where 필터 동적 생성 구현
- Prisma의 count와 groupBy로 전체 카드 수와 등급별 수량 계산
- findMany()로 페이지네이션, 정렬, 선택(select) 필드 적용
- JavaScript 기본값 처리와 객체 구조분해 사용 경험

---

## 🛠️ 작업 상세

### 🔹 구현/수정한 기능

- 사용자 ID 기준으로 카드 목록 조회 함수 `findByUserId` 작성
- 조건부 필터: `grade`, `genre`, `keyword` 값이 있으면 `where` 객체에 동적으로 추가
- 전체 카드 수 조회: `prisma.Photocards.count({ where })`
- 등급별 카드 수 집계: `prisma.Photocards.groupBy({ by: ["grade"], _count: { grade: true } })`
- 등급별 수량을 `{ COMMON: 0, RARE: 0, SUPER_RARE: 0, LEGENDARY: 0 }` 형태로 변환
- 페이지네이션 및 정렬 적용 (`skip`, `take`, `orderBy`)
- 필요한 필드만 선택(select)해서 반환

### 🔹 발생한 이슈 & 해결 과정

- 조건부 필터를 `if문`으로 할지 `...(조건 && {...})` 패턴으로 할지 고민 → **JS 단축평가 + 스프레드** 사용
- `groupBy` 결과 배열 → 객체로 변환 과정에서 초기값 세팅 필요 → `{ COMMON: 0, ... }`로 초기화 후 `forEach`로 값 채움
- `page`와 `pageSize` 기본값 처리 필요 → 나중에 `+req.query.page ?? 1` 같은 패턴 적용 가능

### 🔹 미해결/보류된 이슈

- `groupBy` 결과를 더 깔끔하게 reduce로 객체화하는 방법 실습 필요
- 페이지네이션 기본값과 nullish coalescing 연산자(??) 완전히 이해 후 적용 예정
- 조건이 많아질 경우 if문 vs 스프레드 패턴 최적화 고민

---

## 📓 작업 메모 (코드/아이디어/레퍼런스)

<details>
<summary style="font-size: 22px;">📝 메모장</summary>

1. 기본값 처리

```js
const page = parseInt(req.query.page) || 1;
const pageSize = parseInt(req.query.pageSize) || 15;
```

2. 근데 기본값 설정엔 Nullish Coalescing Operator (??) 사용이 더 안전

```js
const page = +req.query.page ?? 1;
const pageSize = +req.query.pageSize ?? 15;
```

3. `Object.values(Grade).includes(grades)`

- `Object.values(Grade)`: 객체의 값들만 배열로 반환하는 표준 내장 메서드
- `.inclues(grade)`: 그 배열에 grade값이 들어있는지 확인

> #### Q. 어떻게 이 Grade가 enum에 있는 그 데이터인 걸 알지?
>
> `import { Grade } from "@prisma/client"`로 prisma가 schema.prisma 기반으로 JS 코드 변환 과정에서 자동 생성되기 때문
>
> `enum Grade { A B C }`를 prisma가 코드 생성
>
> `export const Grade: { A: 'A', B: 'B', C: 'C' }`
>
> `Grade`는 enum값들을 가진 객체
>
> ```js
> console.log(Grade); // { A: 'A', B: 'B', C: 'C' }
> Object.values(Grade); // ['A', 'B', 'C']
> ```
>
> ⇒ `Grade`: 코드 변환 시점에 자동으로 만들어진 enum 상수. 그래서 `@prisma/client`에서 import해서 써도 전혀 문제XX

4. 굳이 인자로 넘길 때 객체에 담아 넘기고, 매개변수에서 구조분해로 사용하는 이유

- 일반 인자는 순서를 엄격히 유지해야하나 객체면 키로 값을 찾기 때문에 순서가 상관이 없음

5. **JavaScript의 객체 문법과 논리 연산자를 활용한 “조건부 객체 확장”**

<aside>
### **JS에서 조건에 따라 `where` 객체를 동적으로 만드는 방법**

### 1️⃣ 코드 다시 보기

```js
const where = {
  creator_id: userId,
  ...(grade && { grade }),
  ...(genre && { genre }),
  ...(keyword && { name: { contains: keyword, mode: "insensitive" } }),
};
```

#### 구성요소 해석

1. `creator_id: userId`

   - Prisma의 `where`에서 필수 조건.
   - 항상 포함됨.

2. `...(grade && { grade })`

   - **이게 핵심!**
   - JS에서 `&&` 연산자는 왼쪽이 truthy(값이 있으면)일 때 오른쪽을 반환합니다.

     ```js
     true && "hello"; // => 'hello'
     false && "hello"; // => false
     ```

   - `{ grade }`는 `{ grade: grade }`의 축약형.
   - `...` 스프레드 연산자는 객체를 **해체해서 다른 객체 안에 삽입**합니다.

   ✅ 정리하면:

   - `grade`가 있으면 `{ grade: grade }`를 `where` 객체에 넣고
   - `grade`가 없으면 아무것도 안 넣음

3. `...(genre && { genre })`

   - grade와 동일한 원리로, genre가 있을 때만 포함

4. `...(keyword && { name: { contains: keyword, mode: 'insensitive' } })`

   - keyword가 있을 때만 name 검색 조건 추가
   - Prisma에서 `contains`는 부분 일치 검색, `mode: 'insensitive'`는 대소문자 무시

### 2️⃣ JS 동작 예시

```js
const grade = "RARE";
const genre = null;
const keyword = "MJ";

const where = {
  creator_id: userId,
  ...(grade && { grade }), // grade가 있으면 where 객체에 grade:grade 데이터 추가
  ...(genre && { genre }), // 를 spread 문법, JS 단축 평가, 객체 속성 축약형으로 구현
  ...(keyword && { name: { contains: keyword, mode: "insensitive" } }), // prisma의 where 조건 구조
  // prisma의 부분 검색 옵션 (LIKE %keyword%)
  // 대소문자 구분 없이 검색
};

console.log(where);
```

결과:

```js
{
  creator_id: 1,
  grade: 'RARE',
  name: { contains: 'MJ' }
}
```

- genre는 null이어서 들어가지 않았습니다.
- 이렇게 하면 if문 없이도 **조건부 필터링**이 가능해요.

### 3️⃣ 꼭 이렇게 써야 하나?

- **필수는 아니에요.**
- JS에서는 아래처럼 **전통적인 if문**으로도 만들 수 있습니다.

```js
const where = { creator_id: userId };

if (grade) where.grade = grade;
if (genre) where.genre = genre;
if (keyword) where.name = { contains: keyword, mode: "insensitive" };
```

- 실무에서 두 가지 다 쓰입니다.

  - 단순 조건이면 if문이 더 직관적
  - 필터가 많고 코드가 길어지면 **스프레드 + 단축평가** 패턴이 깔끔하고 유지보수 편함

### 4️⃣ 실무에서는?

- 조건이 3~4개 정도면 if문으로도 충분
- 조건이 많아지고, 관계 필드까지 포함되면
**`...(조건 && {...})` 패턴**이 코드 가독성과 유지보수 면에서 유리합니다.
</aside>

6. prisma의 count 메서드

```js
const totalCount = await prisma.Photocards.count({ where });
// SELECT COUNT(*) FROM photocards WHERE creator_id = 1 AND grade = 'RARE';
// where 조건을 만족하는 Photocards 테이블의 레코드 개수를 세라
```

7. grade별 수량 구하기

```js
const gradeCounts = await prisma.Photocards.groupBy({
  by: ["grade"],
  _count: { grade: true }, // grade 컬럼을 카운트해라
});

// 결과
[
  { grade: "COMMON", _count: { grade: 20 } },
  { grade: "RARE", _count: { grade: 8 } },
  { grade: "SUPER_RARE", _count: { grade: 3 } },
  { grade: "LEGENDARY", _count: { grade: 5 } },
];

// 배열 형태임 → gradeCounts[0].grade = 'COMMON'
// _count.grade를 통해 해당 그룹의 수를 확인할 수 있음 → gradeCounts[0]._count.grade = 20
// 만약 { COMMON: 20, RARE: 8, ... }처럼 바꾸고 싶으면 forEach나 reduce로 변환해야 함
```

8. findMany() select 옵션의 false값과 키X 차이

```js
// 키 아예 안 씀
select: {
  id: true,
  name: true
  // grade는 아예 안 썼음
}

// 키 false로 지정
select: {
  id: true,
  name: true,
  grade: false
}
```

| 구분         | 포함 여부 | 결과 객체 | 비고                            |
| ------------ | --------- | --------- | ------------------------------- |
| 키 아예 없음 | 포함 X    | 없음      | 가장 일반적인 방식              |
| 키: false    | 포함 X    | 없음      | 명시적으로 “제외” 의도를 나타냄 |

</details>

---

## 🧠 오늘의 회고 (아쉬움 & 배운 점)

### ✅ 배운 점

- Prisma의 `count`, `groupBy`, `findMany`를 실제로 사용해보며 구조와 문법 감각 습득
- JS 스프레드 + 단축평가(`...(조건 && {...})`) 패턴으로 조건부 객체 생성 가능
- 구조분해 할당과 객체 키 축약, 선택(select) 필드 등 JS 실무 문법 체감
- 페이지네이션, 정렬, 부분 검색(`contains`, `mode: "insensitive"`) 실습

### ⚠️ 아쉬움

- 모든 문법과 Prisma 기능이 처음이라 **많이 헤매고 디버깅 시간 소요**
- `groupBy` → 객체 변환, 조건부 필터 최적화 등 개선 여지 많음
- 코드 전체 흐름과 예외 처리 경험 부족 → 실무 적용 전 더 연습 필요

---

## 🚀 내일의 계획

- GET /cards/me 테스트 및 PR
- GET /cards/:cardId 구현
