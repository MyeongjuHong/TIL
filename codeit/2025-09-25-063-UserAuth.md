# 🗓️ 2025-09-25 TIL 63일차

## ✅ 오늘의 성취 (잘한 점)

- 예
- 예

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

### 🔹 주요 개념 정리

### 🔹 예제 코드

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

## fetch api 개선

next의 고도화된 fetch
= revalidate 가능하다는 뜻

#### fetchClient.js

- api fetch 추상화 틀
- api 요청 표준화 fetch wrapper module
- 중복 코드도 줄여줌!
- 보통 axios는 axios.create()로, fetch는 fetchClient.js로
- 가장 아레 레벨.
- fetch 공통 설정(헤더, 에러 처리, 토큰 등) 담당

#### authService.js, userService.js

- 도메인별(기능별) api 요청 로직 별도 관리 레이어
- api 요청 담당
- 내부적으로 fetchClient 불러서 사용

#### 실제 컴포넌트 훅 (UI)

- authService, userService 호출해서 데이터 get
- UI에서는 fetchClient 직접X 서비스 레이어만 의존

쿠키에서 캐시는 계속 가지고 있으면 위험에 노출될 수도 있고 애초에 굳이 캐싱할 필요가 없음

try catch를 fetch쪽에 넣으면 안되는 이유  
 화면마다 catch대처를 달리 해야해서 추상화하기 적절하지 않음. 이건 최대한 화면(페이지파일)에 가까이 둬야함

개발단에서 사파리 인증이 어려운 이유  
 = 사파리는 브라우저 보안이 엄격한 편. 현재 json-server로 사용하는 서버는 https고, 프론트 서버가 http기 때문에 네트워크 보안도 다르고 프론트쪽 네트워크 보안이 약해 인증이 어려운 상황. 배포 후 security를 사용하면 문제가 해결될 것.

## context api로 유저 데이터 관리하기

#### Q.리액트 쿼리도 전역적으로 감싸는데, 왜 인증 상태는 Context API로 관리하는게 나을까?

- 리액트 쿼리는 `서버 상태 관리 라이브러리`
- `백엔드 서버와 동기화되는 데이터`의 캐싱, refetch, 업데이트 용
- ex) 게시글 목록, 유저 상세 정보, 검색 결과

- Context API는 `클라이언트 상태 공유`
- 서버와 무관히 앱 내부에서 전역적으로 필요로 하는 상태를 전달
- ex) 현재 로그인한 사용자, 다크 모드 여부, 언어 설정

> #### 인증상태는 서버에서 매번 새로 가져와야하는 서버 상태가 아닌
>
> #### 앱이 켜져 있는 동안은 변하지 않고 앱 전역에서 필요로 하는 클라이언트 상태에 더 가까움

react query로만 관리하면 컴포넌트 첫 마운트 때마다 api 요청 발생  
=> 불필요한 네트워크 요청과 복잡한 invalidate 처리 발생

## context api

context
1. 만든다 - createContext
2. 내보낸다 - AuthProvider (value를 전역에서 쓰겠다)
3. 사용한다 - useContext (우리가 만든 컨텍스트를 인자로 꼭 넣어야함)
4. 근데 useContext를 page단에서 쓰면 여러 context 관리시에 헷갈릴 수 있으니 useHook으로 따로 빼둬서 context 객체를 미리 지정해놓으면 관리가 편함! 이래서 관심사 분리를 하는구먼


isLoading false시점 이유?
=> ㄹ우팅 결정이 다 되고 나서야 false로 바꿈

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 예
- 예

---

## 🚀 내일의 계획

- 예
- 예

---
