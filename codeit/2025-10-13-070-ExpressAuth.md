# 🗓️ 2025-10-13 TIL 70일차

## ✅ 오늘의 성취 (잘한 점)

- 예
- 예

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

1. MVC

### 🔹 주요 개념 정리

### 🔹 예제 코드

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

# Express Auth

```shell
express-user-system/
├── src/
│   ├── controllers/     # 요청/응답 처리 및 서비스 계층 연결
│   ├── services/        # 비즈니스 로직 처리
│   ├── repositories/    # 데이터베이스 작업 처리
│   ├── middlewares/     # 미들웨어 함수들
│   ├── config/         # 환경 설정 관련 파일들
│   └── app.js          # 애플리케이션 시작점
├── prisma/             # Prisma 스키마 및 마이그레이션
├── http/               # API 테스트용 HTTP 요청 파일들
├── .env               # 환경 변수 설정
└── package.json       # 프로젝트 설정 및 의존성

# Client 요청 → Controller → Service → Repository → Prisma(Database)
```

## Controller

1. 요청 파싱

- req.params, req.query, req.body, 쿠키/헤더 추출

2. 요청 유효성 검사 (형식/필수값)

- 빠른 4XX 처리 (예: 필수 필드 없으면 422)

3. 인증/인가 결과 활용

- 미들웨어가 설정한 req.user 사용

```js
// authMiddleware.js
export default function auth(req, res, next) {
  // 예: JWT 디코드 후
  // const { userId, role } = verify(token)
  req.user = { userId: 1, role: "user" };
  next();
}

// app.js
app.use(auth);
```

4. 서비스 호출

- 비즈니스 로직은 호출만

5. 응답 구성

- 상태코드/헤더/바디 결정

6. 에러 위임

- try/catch에서 next(error)로 중앙 에러 핸들러에 전달

7. 하지 말아야 할 것

- DB 접근, 비즈니스 규칙 구현, 비밀번호 해시 등

> #### 외 않되?
>
> 1. 역할 분리 원칙
>
> - Controller는 기본적으로 HTTP 요청을 받아 적절한 서비스 레이어에 전달, 결과를 클라이언트에 반환
> - DB 직접 조회시
>   - DB 구조가 바뀌면 Controller까지 수정해야해 유지보수 어렵~
>   - 테스트도 어려워짐
>
> ⇒ 요청과 응답만 담당! 실제 로직은 Service / Model에서 처리하는게 깔끔!
>
> 2. 비즈니스 규칙(로직) 구현
>
> - 회원가입 시 이메일 중복 확인, 포인트 적립 계산 등
> - Controller에서 이런 규칙 구현시
>   - 로직이 Controller에 흩어져 재사용 어렵
>   - 다른 곳에서도 같은 로직을 써야 한다면 코드 중복 발생
>
> ⇒ Service 계층에서 처리시 여러 Controller에서 재사용 가능 & 테스트 EZier
>
> 3. 비밀번호 해시
>
> - `bcrypt` 같은 라이브러리 이용해 비밀번호 해시할 때도 Controller에서 바로 하기 금지
>   - 보안 로직이 Controller 안에 있으면 나중에 수정하거나 다른 인증 방식 도입시 Controller 전체 건드려야 함
>   - Service나 Auth Helper 같은 별도 모듈에서 처리하면 깔끔한 코드를 안전히 관리 가능
>
> | 계층             | 역할                                              |
> | ---------------- | ------------------------------------------------- |
> | Controller       | 요청 처리, 서비스 호출, 응답 반환                 |
> | Service          | 비즈니스 로직 처리, 데이터 검증, 비밀번호 해시 등 |
> | Model/Repository | DB 접근                                           |

## Service

> #### 비즈니스 로직의 중심
>
> 도메인 규칙, 시나리오 흐름 (가입 → 중복확인 → 해시 → 저장)

1. 도메인 유효성 검사

- 규칙 검증: 해당 사용자 존재 여부, 권한/상태 체크

2. 트랜잭션/오케스트레이션: 여러 Repository 호출 묶기 // QUES: 왜..?

- 여러 저장/수정이 한 묶음(원자성)이어야 할 때 서비스가 트랜잭션 경계 잡는 것이 일반적
- 컨트롤러가 여러 서비스 호출 & 원자성 필요시 상위 오케스트레이션 서비스(컴포지트 서비스)를 만들어
  - 그 안에서 한 번의 트렌젝션으로 묶기 가능
  - 컨트롤러에서 따로따로 호출시 정합성 깨질 수 O

3. 인프라 연동

- 외부 API, 큐, 캐시, 암호화/해시 등 // QUES: 큐가 왜 인프라..?

4. 데이터 가공

- 반환용 마스킹/정규화 (예: 비밀번호 제거)

5. 에러 생성/전파

- 의미 있는 에러(코드/메세지)로 throw → 컨트롤러가 상태코드 매핑

6. 하지 말아야 할 것

- HTTP 세부(req, res, 상태코드), 프레임워크 의존 처리 // QUES: 프레임워크가 프론트엔드단 말하는건가?
  - 가급적 프레임워크의 req, res 등을 서비스에서 처리하지 말자는 뜻
  - 서비스는 `순수 비즈니스 로직에 집중`해야한다는 원칙

> ### 왜..?
>
> 1. 왜 트랜잭션/오케스트레이션(여러 Repository 호출 묶기) 필요할까?  
>    데이터 일관성을 위해 일관성 있는 작업을 Controller에서 각각 호출X  
>    트랜잭션 경계를 서비스 레벨에서 잡아 하나의 트랜잭션으로 묶기
>
> 2. 큐가 왜 인프라일까?  
>    데이터베이스와 같은 외부 시스템 (메세지 큐: RabbitMQ, Kafka - 비동기 처리 인프라)
>
> 3. 백엔드 프레임워크 의존 금지  
>    `req, res 객체`, `HTTP status code`는 프레임워크 레벨의 책임  
>    Service 레이어에서는 순수 js,ts 객체를 받아 비즈니스 로직만 처리할 것
>
> - 하지 말아야 할 예시
>
> ```js
> async function createUser(req, res) {
>   // ❌ Service가 HTTP에 의존
>   const user = await userRepository.save(req.body);
>   res.status(201).json(user);
> }
> ```
>
> - 올바른 예시
>
> ```js
> // Controller
> async function createUserController(req, res) {
>   const result = await userService.createUser(req.body);
>   res.status(201).json(result);
> }
>
> // Service
> async function createUser(data) {
>   const user = await userRepository.save(data);
>   return user;
> }
> ```

## Repository

> #### 데이터 접근 전담
>
> Prisma/ORM 이용한 CRUD, 쿼리 최적화

1. DB 트랜잭션 단위 작업

- 제공된 트랜잭션 컨텍스트 내에서 쿼리 실행
  - 이 트랜잭션 단위의 제공은 `Service`에서!

2. DB 제약 활용

- 유니크/외래키 등 스키마 레벨 보장

3. 순수함 유지

- 입력 데이터 그대로 저장/조회, 비즈니스 규칙XX

4. 예외 처리

- ORM 에러는 가급적 래핑 없이 그대로 상위(Service)로 전파할 것

5. 하지 말아야 할 것

- HTTP 응답/상태, 도메이 규칙 판단, 요청 형식 검증

### 예시

```js
// app.js
...
app.use('/products', productController);
app.use(errorHandler);
...

// controllers/productController.js
const productController = express.Router();

productController.post('/', async (req, res, next) => {
  try{
    const createdProduct = await productService.create(req.body);
    return res.status(201).json(createdProduct);
  } catch(err) {
    return res.status(500).json({ message: err.message });
  }
});

productController.get('/:id', async (req, res) => {
  try {
    const { id } = req.params; // 요청 파싱
    const product = await productService.getById(id); // 서비스 호출
    return res.status(200).json(product);
  } catch (err) {
    return res.status(500).json({ message: err.message });
  }
});

// services/productServices.js
async function getById(id) {
  const product = await productRepository.getById(id);
  if (!product) throw new Error('Product not found');
  return product;
}

async function create(product) {
  return await productRepository.save(product);
}

// repositories/productRepository.js
async function getById(id) {
  return await prisma.product.findUnique({
    where: {
      id: parseInt(id, 10),
    },
  });
}

async function save(product) {
  return await prisma.product.create({
    data: {
      name: product.name,
      description: product.description,
      price: parseInt(product.price, 10),
    },
  });
}
```

<details><summary>정리본</summary>

### 1️⃣ Controller (컨트롤러)

- **역할:** 클라이언트 요청을 받고, 응답을 반환하는 최전선.
- **책임:**

  - HTTP 요청(req)에서 데이터 가져오기 (query, params, body)
  - 서비스 계층(service) 호출
  - HTTP 응답(res) 반환
  - 에러 처리 및 상태 코드 설정

- **주의점:** 비즈니스 로직을 여기에 넣지 말고, 단순히 요청/응답과 서비스 호출만 담당.

**예시:**

```javascript
// controllers/userController.js
import userService from "../services/userService.js";

async function getUser(req, res) {
  try {
    const userId = req.params.id; // 요청 URL에서 ID 추출
    const user = await userService.findUserById(userId); // 서비스 호출
    return res.status(200).json(user); // 클라이언트에 응답
  } catch (error) {
    return res.status(500).json({ message: error.message }); // 에러 처리
  }
}

export default {
  getUser,
};
```

---

### 2️⃣ Service (서비스)

- **역할:** 비즈니스 로직 처리 계층.
- **책임:**

  - Controller로부터 받은 데이터를 기반으로 실제 비즈니스 로직 수행
  - 필요한 경우 여러 Repository를 조합해서 데이터 처리
  - 외부 API 호출, 트랜잭션 처리 등

- **주의점:** DB나 HTTP 레이어와 직접적으로 섞이지 않게, Repository를 통해 데이터 접근.

**예시:**

```javascript
// services/userService.js
import userRepository from "../repositories/userRepository.js";

async function findUserById(id) {
  // 비즈니스 로직: 사용자 존재 여부 확인
  const user = await userRepository.getUserById(id);
  if (!user) throw new Error("User not found");
  return user;
}

export default {
  findUserById,
};
```

---

### 3️⃣ Repository (레포지토리)

- **역할:** 데이터 접근 계층, DB와 직접 통신.
- **책임:**

  - CRUD 작업 수행 (Create, Read, Update, Delete)
  - DB 쿼리 작성 및 실행
  - 데이터 모델 변환

- **주의점:** 비즈니스 로직은 포함하지 않고, 오직 DB 접근만 담당.

**예시:**

```javascript
// repositories/userRepository.js
const db = require("../models"); // 예: Sequelize ORM 모델

exports.getUserById = async (id) => {
  return await db.User.findByPk(id); // Sequelize로 DB 조회
};
```

---

### 🔑 정리

| 계층       | 책임                                          |
| ---------- | --------------------------------------------- |
| Controller | HTTP 요청/응답 처리, 서비스 호출              |
| Service    | 비즈니스 로직 처리, 여러 Repository 조합 가능 |
| Repository | DB 접근, CRUD 수행, 데이터 모델 관리          |

- Controller → Service → Repository → DB
- 이렇게 계층을 나누면 **코드 재사용성 ↑, 테스트 용이 ↑, 유지보수 용이 ↑**

</details>
</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 예
- 예

---

## 🚀 내일의 계획

- 예
- 예

---
