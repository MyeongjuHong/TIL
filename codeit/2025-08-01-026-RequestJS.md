# 🗓️ 2025-08-01 TIL 26일차

## ✅ 오늘의 성취 (잘한 점)

- fetch 공부 완!!

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

AJAX와 fetch API를 이용한 비동기 통신 처리 및 네트워크 요청 흐름 정리

---

### 🔹 주요 개념 정리

- **AJAX 정의**: Asynchronous JavaScript And XML의 약자로, 페이지 새로고침 없이 서버와 비동기 통신 가능
- **fetch 함수 사용법**: 기본 문법 `const res = await fetch('url')`
- **응답 처리 방식**:

  - 상태 코드 확인 → `res.status`
  - 헤더 접근 → `res.headers`
  - 바디 접근 → 메서드 사용 필수

    - 일반 텍스트 → `await res.text()`
    - JSON → `await res.json()` (응답 헤더의 `Content-Type`으로 데이터 유형 확인)

- **구조 분해 할당**: `const { 프로퍼티명 } = data` 방식으로 사용 가능

---

### 🔹 예제 코드

```js
const res = await fetch("https://example.com/api");
const data = await res.json();
const { name } = data;
```

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

### 🔹 핵심 주제

- AJAX: Asynchronous JavaScript And XML (비동기 자바스크립트와 XML)
- JavaScript에서 `fetch`를 사용한 API 요청 처리

---

### 🔹 주요 개념 정리

#### ✅ AJAX

- Asynchronous Javascript And XML
- 비동기 자바스크립트와 XML

#### ✅ fetch

- 기본 사용:  
  `const res = await fetch('url');`

- 상태 코드 접근:  
  `res.status`

- 응답 헤더 접근:  
  `res.headers`

- 응답 바디:

  - 프로퍼티로 직접 접근 불가
  - 메서드 사용 필요
    - 일반 문자열: `await res.text()`
    - JSON 문자열: `await res.json()`
    - 응답 헤더의 Content-Type을 통해 응답 형식 확인 가능

- 구조 분해 할당:  
  `const data = await res.json();`  
  `{ 프로퍼티명 } = data`

---

#### ✅ GET 요청

- 쿼리 파라미터를 통한 필터링 및 페이지네이션 가능
- URL 객체 사용 예시:

  ```js
  const url = new URL("url");
  url.searchParams.append("파라미터키", 값);
  ```

- 페이지네이션을 위한 파라미터:

  - `offset`: 건너뛸 데이터 개수
  - `limit`: 요청할 데이터 개수

```js
const params = { offset: 10, limit: 10 };
const url = new URL("https://learn.codeit.kr/api/color-surveys");
Object.keys(params).forEach((key) => url.searchParams.append(key, params[key]));
const res = await fetch(url);
const data = await res.json();
console.log(data);
```

---

#### ✅ POST 요청

```js
fetch("url", {
  method: "POST",
  body: JSON.stringify(객체),
  headers: {
    "Content-Type": "application/json",
  },
});
```

- `method`: 'POST', 'PATCH', 'DELETE' 등
- `body`: JSON 문자열 (객체 → JSON.stringify 처리 필요)
- `headers`: Content-Type 명시 필수

---

#### ✅ API 함수 구조화

- API 함수는 별도 파일에서 정의 후 import하여 사용
- 예시 1 - 페이지네이션 함수

```js
export async function 함수명(params = {}) {
  const url = new URL("url");
  Object.keys(params).forEach((key) =>
    url.searchParams.append(key, params[key])
  );
  const res = await fetch(url);
  const data = await res.json();
  return data;
}
```

- 예시 2 - 필터링 함수

```js
export async function 함수명(id) {
  const res = await fetch(`url/${id}`);
  const data = await res.json();
  return data;
}
```

- 예시 3 - POST 함수

```js
export async function 함수명(객체) {
  const res = await fetch("url", {
    method: "POST",
    body: JSON.stringify(객체),
    headers: {
      "Content-Type": "application/json",
    },
  });
  const data = await res.json();
  return data;
}
```

- import 예시

```js
const 객체 = {
  키: 값,
  키2: 값2,
};
const data = await 함수명(객체);
```

---

#### ✅ 오류 처리

- Rejected 상태 발생 조건

  - 유효하지 않은 주소
  - 잘못된 헤더

- Fulfilled 상태이지만 실패 응답의 예시

  - 400: 잘못된 바디
  - 500: 서버 오류

- `res.ok` 프로퍼티를 통한 실패 여부 확인

- 예외 발생 시 `throw new Error` 사용

```js
export async function getColorSurvey(id) {
  const res = await fetch(`https://learn.codeit.kr/api/color-surveys/${id}`);
  if (!res.ok) {
    throw new Error("데이터를 불러오는데 실패했습니다.");
  }
  const data = await res.json();
  return data;
}
```

- 호출 시 try-catch 처리

```js
try {
  const data = await getColorSurvey(1234);
  console.log(data);
} catch (e) {
  console.log("오류 발생:");
  console.log(e.message);
}
```

---

#### ✅ 웹 브라우저 API 네트워크 확인

- 네트워크 탭에서 요청 확인 가능

  - Method, Status, Type, Initiator, Size, Time, Waterfall

- 세부 정보 탭

  - Headers: 요청/응답 헤더
  - Preview: 응답 미리보기
  - Response: 포맷 정리된 응답 바디

- 기능

  - Preserve log로 기록 유지
  - preflight 요청 자동 전송
  - 필터 사용 (Fetch/XHR 등)
  - Throttling으로 속도 시뮬레이션 가능

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- axios 다 못할 것 같다..

---

## 🚀 내일의 계획

- 시간 날 때 꼭 따라잡고, 월요일에는 스프린트4!

---
