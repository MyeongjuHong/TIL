# 🗓️ 2025-08-12 TIL 33일차

## ✅ 오늘의 성취 (잘한 점)

- CS 스터디 완!! 이미 알고있는 내용이라 괜히 신청했나 싶었는데, 지금은 실무와 연관지으며 공부하니 정말 새롭게 다가오더라. 신청하길 잘했다!
- 영양제 덕분인가.. 몸이 쌩쌩해졌다! 그래도 잠은 꾸준히 잘 것.

---

### 🔹 핵심 주제

React에서 **네트워크 데이터 처리**, **페이지네이션**, **비동기 state 변경**, **로딩·에러 처리**, **옵셔널 체이닝**

### 🔹 주요 개념 정리

- **useEffect**: 의존성 배열(\[]) 사용해 초기 렌더 시 한 번만 실행
- **데이터 정렬**: `order` 변경 시 API 재호출 → state 업데이트 → 재렌더링
- **페이지네이션**: offset/limit 또는 cursor/limit 기반, 기존 데이터에 추가(Spread)
- **조건부 렌더링**: `&&`, `||`, 삼항연산자 `? :`
- **비동기 state 변경 시 콜백**: 이전 state 참조 시 `(prev) => ...` 형태로
- **콜백 초기값**: useState 초기값을 함수로 전달 시 최초 렌더에만 실행
- **로딩 처리**: `isLoading` state로 버튼 비활성화 및 상태 표시
- **옵셔널 체이닝(?.)**: 외부 데이터, 조건부 객체 접근 시 안전하게
- **네트워크 에러 처리**: `loadingError` state에 에러 저장 후 UI에 표시

### 🔹 예제 코드

```jsx
// 데이터 불러오기
useEffect(() => {
  const fetchData = async () => {
    try {
      setIsLoading(true);
      const reviews = await getReviews(order);
      setItems(reviews);
    } catch (error) {
      setLoadingError(error);
    } finally {
      setIsLoading(false);
    }
  };
  fetchData();
}, [order]);

// 비동기 + 이전 state 참조
const handleAddClick = async () => {
  await addCount();
  setCount((prevCount) => prevCount + 1);
};
```

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

## 데이터 가져오기

- 목데이터 대신 네트워크 데이터로 전환

---

### 🔹 useEffect

- **API 무한루프 발생 시**: 개발자도구 → Sources 탭 → ⏸ 버튼
- **무한루프 발생 이유**
  1. 초기 컴포넌트 렌더링
  2. 비동기 함수 실행 → 대기
  3. JSX 렌더링
  4. `await` 완료 후 `setItems` 실행
  5. `useState` 변경 감지 → 컴포넌트 재렌더링
  6. 반복…
- **해결**: 최초 렌더링에서만 요청 → `useEffect(() => 함수(), []);`

#### 정렬에 따른 데이터 불러오기

- `useEffect`는 렌더링이 끝난 뒤 콜백 실행
- 의존성 배열([]) 내 값이 변경될 때만 재실행
- 실행 흐름:
  1. 사용자가 `order` 변경 (`setOrder('calorie')`)
  2. state 변경 → 재렌더링
  3. React가 의존성 배열 비교
  4. 값이 다르면 `useEffect` 실행
  5. `handleLoad(order)` → `getReviews(order)` 호출
  6. `setItems(reviews)` → state 갱신 → 재렌더링

---

### 🔹 페이지네이션 (useState)

1. **오프셋 기반**: `offset`, `limit` 사용
2. **커서 기반**: `cursor`, `limit` 사용

- **추가 데이터 불러올 때**: 기존 배열에 **덮지 않고** 추가 (`spread` 사용)
- 흐름:
  1. `offset`과 `limit`으로 초기 데이터 요청
  2. 초기값이면 그대로, 아니면 배열 합치기
  3. `offset` 갱신 (`offset + limit`)

---

### 🔹 조건부 렌더링

- `{변수 && JSX}`: 값이 있으면 출력
- `{변수 || JSX}`: 값이 없으면 출력
- `{조건 ? JSX1 : JSX2}`: 조건에 따라 선택
- ⚠️ 변수의 `falsy` 값 주의

---

### 🔹 비동기 State 변경

- 비동기 상황에서 **이전 state 값**을 사용해야 하면 콜백 전달:

```jsx
setState((prev) => [...prev, ...newData]);
```

- 예:

```jsx
const handleAddClick = async () => {
  await addCount();
  setCount((prevCount) => prevCount + 1);
};
```

---

### 🔹 콜백으로 초기값 지정

```jsx
const [values, setValues] = useState(() => {
  const savedValues = getSavedValues(); // 처음 렌더링 시만 실행
  return savedValues;
});
```

- 콜백이 오래 걸리면 초기 렌더링 지연 가능

---

### 🔹 네트워크 로딩 처리

1. `isLoading` state 생성 (기본값 `false`)
2. API 호출 전 `true`
3. 호출 후 `false`
4. 버튼 `disabled`에 `isLoading` 사용

---

### 🔹 옵셔널 체이닝

1. 옵셔널 체이닝을 써야 하는 경우
   **"외부에서 들어오는 데이터"**나 **"조건부로 만들어지는 객체"**
   예시
1. API 응답 데이터

```jsx
const user = apiResponse.user;
console.log(user?.profile?.nickname);
// user 또는 profile이 undefined여도 안전
```

2. 중첩된 객체 탐색

```jsx
const city = data?.address?.city;
// data.address가 없을 경우 에러 방지
```

3. 이벤트 객체

```jsx
const handleClick = (event) => {
  console.log(event?.target?.value);
};
```

4. 옵션/설정 객체

```jsx
const themeColor = config?.theme?.color || "default";
```

---

### 🔹 네트워크 에러 처리

1. `loadingError` state 생성
2. API 호출 전 `setLoadingError(null)`
3. 실패 시 `setLoadingError(error)`
4. JSX:

```jsx
{
  loadingError?.message && <span>{loadingError.message}</span>;
  // loadingError가 null값일 수도 있으니 옵셔널 체이닝 설정
  // 아니면 message 접근 과정에서 에러가 남(그냥 false XX)
}
```

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 느리다. 많이 밀림
- 스터디 과제와 위클리페이퍼를 오전시간에 배치해두니 그 공부들은 잘 하는데.. 오히려 정규 시간 공부가 5시간 뿐이라 조금 부족한 것 같다.

---

## 🚀 내일의 계획

- 위클리 페이퍼, 코테 과제, CS 과제와 정규 강의/실습/스프린트 배치를 더 고민해볼 것..
- 얼른 스프린트5 끝내자!!

---
