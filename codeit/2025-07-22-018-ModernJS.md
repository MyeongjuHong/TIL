# 🗓️ 2025-07-22 TIL 18일차

## ✅ 오늘의 성취 (잘한 점)

- 모던JS 거의 다 끝내다!!
- 회사 다니길 정말 잘한 것 같다. 그 당시에는 허덕였는데, 지금 접하니 정말 이해가 쉽다!

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

### 🔹 주요 개념 정리

### 🔹 예제 코드

<details>
<summary style="font-size: 22px;">📓 메모장</summary>
# Modern JS

## JS 문법/표현

문장? 어떤 동작이 일어나도록 작성된 최소한의 코드 덩어리
표현식? 결과적으로 하나의 값이 되는 모든 코드

표현식이면서 문장? 할당식과 함수호출

```
// 할당 연산자는 값을 할당하는 동작도 하지만, 할당한 값을 그대로 가지는 표현식이다.
title = 'JavaScript'; // JavaScript

// 함수 호출은 함수를 실행하는 동작도 하지만, 실행한 함수의 리턴 값을 가지는 표현식이다.
sayHi(); // sayHi 함수의 리턴 값

// console.log 메소드는 콘솔에 아규먼트를 출력하는 동작도 하지만, undefined 값을 가지는 표현식이다.
console.log('hi'); // undefined
```

표현식이 아닌 문장? 변수에 할당 불가, 인자로 전달 불가
JS에서 표현식 문장은 세미콜론, 표현식 아닌 문장은 중괄호로 범위 구분

### 조건 연산자 (삼항 연산자)

조건 ? 참일때 실행할 표현식 : 거짓일때 실행할 표현식
표현식만 가능! 변수 선언 및 문장 실행 불가~~

### spread

배열 다룰때 유용함
여러개의 값을 하나로 묶은 배열을 다시 각각의 개별 값으로 펼치는 문법
배열, 문자열, Set, Map등 이터러블 객체에서 이터러블 구조 분해
ㄴ 이터러블? 반복 가능한 자료구조(해당 객체 안에Symbol.iterator 메서드 있어야함)
ㄴ JS가 미리 정의해놓은 순회 규칙 메소드
ㄴ iterator라는 특별한 객체 리턴, next() 메서드로 값을 하나씩 추출
ㄴ for … of 나 …arr 같은 문법이 자동으로 수행
…arr은 배열을 그냥 넘기는게 아닌 arr[0], arr[1], arr[2]를 각각의 인자로 분해해 전달
…은 for of 반복문처럼 이터러블의 값을 하나씩 추출!
ㄴ 문법적으로 반복문 아닌, 내부적으로 Symbol.iterator 호출해 순회하는 구조

가변 인자인 console.log는 이 인자를 그대로 출력

```
const arr = [1, 2, 3];
console.log(...arr);

console.log(1, 2, 3) //과 호출 결과 동일
```

전달 대상이 누구냐에 따라 동작 방식이 다름!

- 함수 인자에 …arr은 펼쳐서 인자로 여러 넘겨주는 문법
- 배열 리터럴에 …arr은 배열의 요소를 낱개로 꺼내서 새 배열에 할당
- 문자열에서는 글자 하나하나로 펼쳐짐
- set/map는 요소 펼쳐서 배열로 변환 가능

#### rest parameter vs spread

rest parameter

- 여러개의 인자값들을 하나의 파라미터로 묶는 방식
  spread
- 하나로 묶여있는 값을 개별 값으로 펼치는 방식

이전에 배열에서 값을 공유하는 참조 문제도 spread를 사용하면 편리하게 복사 가능!

배열 두개를 합치는 것도 ez함

- const arr3 = […arr1, …arr2];

함수 호출 시 인자로도 활용

- const arr = [요소1, 요소2, 요소3, …];
- 함수명(…arr); //요소 하나하나하 인자로 전달
- // 함수명(요소1, 요소2, 요소3, …) 이거랑 같은 뜻임

rest parameter는 매개변수에
spread는 인자로

주의! spread 구문은 값 그 자체가 아님! 특정 문맥에만 사용

1. 배열 리터럴
2. 객체 리터럴
3. 함수 호출에서의 인자값
4. const 변수명 = ...args; // 에러!

spread 이용해 배열요소 -> 객체 속성값으로 할당 가능
ㄴ 객체 속성키 배열의 인덱스번호로 자동 매핑

#### spread in object

```
const codeit = {
  name: 'codeit',
};

const codeitClone = {
  ...codeit, // spread 문법!
  age: 26
};

console.log(codeit); // {name: "codeit"}
console.log(codeitClone); // {name: "codeit”, age: 26}
```

객체는 배열로 spread도, 함수 인자값으로 spread도 불가!
객체 spread시 중괄호 안에서만 사용 가능

### 객체 프로퍼티 표기

속성명과 속성값 이름이 같을 때 속성명만 써도 됨

- 속성값이 변수일 때
- 속성값이 함수명일 때

```
function 함수명() { }
const 변수명1 = 값;
const 변수명2 = 값;

const 객체명 = {
	변수명1,
	변수명2,
	함수명,
}
```

객체 내부에서 익명 함수 표기법으로 메소드 선언할 때도 :과 function 생략해서 함수명() { }으로 표기 가능

```
const 객체명 = {
	키1: 값,
	키2: function() {  },
	키3() {  }, // 키2를 키3처럼 표기 가능
```

ㄴ 이것도 실무에서 알쏭달쏭했던 이유였네…

++ 속성명을 표현식으로? (계산된 속성명)
대괄호 안에 변수나 표현식을 넣어서 객체의 속성 이름을 동적으로 지정하거나 구조분해 할당 시 해당 속성을 꺼낼 수 있는 문법

```
const 객체명 = {
	[표현식]: 값,
};
```

```
const 객체명 =  {
	[`${변수명1}`+’값1’]: 속성값,
	[변수명2]: 속성값,
	[함수명()]: 속성값, //함수 리턴값이 속성명으로
```

프로퍼티 구분은 쉽표로
객체 내 메서드는 되도록이면 화살표 함수보다 일반 함수로!

### 옵셔널 체이닝 ?.

왼쪽프로퍼티?.오른쪽프로퍼티

- 왼쪽 프로퍼티 값이
- undefined나 null이면 undefined 반환
- 그게 아니면 그 다음 프로퍼티 값을 반환!
  (왼쪽프로퍼티 === null || 왼쪽프로퍼티 === undefined) ? undefined : 오른쪽프로퍼티

null 병합 연산자와 자주 사용
ex) console.log(user.cat?.name ?? ‘고애옹없’);
ㄴ user.cat이 null/undefined면 고애옹없 반환, 있으면 name 반환

### 구조분해

배열이나 객체의 구조를 분해해서, 그 안의 값을 개별 변수에 할당하는 문법
const [변수1, 변수2, …나머지] = 할당할 배열;
const {변수1, 변수2, …나머지} = 할당할 객체;

#### 배열 구조분해

상태

- 여러 값들이 나열된 배열 변수 선언
- 변수에 배열 전체 할당
  - const 배열명 = [요소1, 요소2, …];

기존 할당

- 변수 하나에 배열의 요소를 할당
  - const 변수명1 = 배열명[0]; //요소1
  - const 변수명2 = 배열명[1]; //요소2
  - … //계속 할당

구조분해 할당

- 왼편에 변수의 이름들이 대괄호 감싼 형태로 선언, 오른편의 배열 자체를 할당 - const [변수명1, 변수명2, …] = 배열명;
  => 오른편 배열의 요소들이 순서대로 왼편 배열에 할당

주의!

- 오른쪽에서 할당할 값은 일반 기본값 불가! (배열/객체만 가능)
- 할당할 값이 없어도 에러! 무조건 할당할 값이 있어야 함
- 참고!
- 배열 요소가 구조분해 배열 변수 요소보다 많으면 나머지 요소들 무시됨
  - rest 문법으로 남은 요소들을 배열에 담아놔도 됨
- 배열 요소가 구조분해 변수 배열 요소보다 적으면 남은 변수에는 undefined 자동 할당
  - 함수 파라미터 기본값처럼 구조분해 배열 변수에도 기본값 할당 가능
- 변수에 할당된 값을 서로 교환할 때도 사용?
  - [변수1, 변수2] = [변수2, 변수1];
    - [변수2, 변수1]은 새로운 배열 리터럴 [값1, 값2]
    - 그 변수를 순서대로 왼쪽의 구조분해 배열/패턴에 할당
    - 보통 이미 선언된 변수를 값을 바꿔 재할당하기 때문에 앞에 const, let 사용X (재선언 불가)

#### 객체 구조분해

객체 프로퍼티(속성) 사용 시 점 표기법으로 프로퍼티 접근하지 않고 프로퍼티명 자체를 변수처럼 사용할 때 사용!
상태

- 객체 변수 선언
  - const 객체명 = {키:값, 키:값, …};

기존 할당

- 변수 하나에 객체 속성값 할당
  - const 변수명1 = 객체.속성명;
  - const 변수명2 = 객체.속성명;
  - … //계속 할당

구조분해 할당

- 왼편에 변수의 이름들이 중괄호 감싼 형태로 선언, 오른편의 객체를 할당 - const {속성명1, 속성명2, …} = 객체명;
  => 오른편 객체의 속성명과 이름이 같은 변수에 속성값 할당

참고!

- 속성명 이름에 해당하지 않는 변수엔 undefined 자동 할당
- 기본값 설정 가능 `변수 = ‘값’`
- rest 문법으로 나머지 속성들을 새 객체로 모아 할당 가능

  - const {속성명, 속성명, …rest} = 객체명;
  - 나머지 속성들을 모아 rest란 객체에 할당

- 꼭 같은 이름의 속성으로만 매핑해야 할까? NO
  - `속성명:변수명`으로 원하는 변수명 설정 가능
  - const { 속성명: 변수명, 변수명, … } = 객체명;
  - 변수로 사용할 수 없는 속성명 (ex.속-성-명)은 구조분해 할당 시 꼭 새 변수명으로 매핑해야 함
  - 계산된 속성명도 사용 가능
    - const 변수명 = ‘속성명’;
    - const { [변수명]: 새변수명 } = 객체명;
    - const { 속성명: 새변수명 } = 객체명;과 같음

```
//예제1
const user = {
  name: ‘이름,
  age: 26,
  job: ‘직업’
};

function getUserField(fieldName) {
  // fieldName은 실행 중에 동적으로 들어옴 (예: 'age')
  const { [fieldName]: value } = user;
  return value;
}

//예제2: api 응답에서 키가 상황마다 바뀜
const response = {
  user_id: 123,
  admin_id: 456
};

const role = 'admin'; // 또는 'user'

const key = `${role}_id`; // 'admin_id' or 'user_id'

const { [key]: id } = response;

//예제3: react에서 동적으로 특정 속성만 을 업데이트해야함
function handleChange(key, value) {
  setState(prev => ({
    ...prev,
    [key]: value
  }));
}
```

### 구조분해 함수 응용

#### 배열 구조분해 응용

```
function 함수명(…args) {
	const [변수1, 변수2, 변수3, …rest] = args;
	// rest로 받은 args배열을 변수에 할당
	…
}
함수명(인자1, 인자2, 인자3, …);

//근데 이거를

function 함수명([변수1, 변수2, 변수3, …rest])  {
	…
}
const 배열명 = [요소1, 요소2, 요소3, …];
함수명(배열명);
```

상황 목적 가능한 문법
함수 정의 (파라미터) 인자들을 모아서 하나로 받기 ✅ ...rest만 가능
함수 호출 (인자 전달) 배열 등을 풀어서 전달 ✅ ...spread만 가능
spread는 "보낼 때", rest는 "받을 때"만 쓰인다.

#### 객체 구조분해 응용

매번 객체 프로퍼티에 접근할 필요 없이 구조분해 할당으로 변수 사용 가능

```
const 객체명 = {속성명: 속성값, 속성명: 속성값, …}

function 함수명(object) {
	const {속성명, 속성명, 속성명 } = object;
	…
}

함수명(객체명);

//근데 이 함수부분 더 개선 가능

function 함수명({ 속성명, 속성명, 속성명 }) {
	…
}


```

#### HTML 요소

event Listener에서 event가 아닌 target 속성을 매개변수로 잡으면 더 간결하게 접근 가능

```
btn.addEventListener(‘click’, (event) => {
	event.target.classList.toggle(‘checked’);
});

btn.addEventListener(‘click’, ({ target }) => {
	target.classList.toggle(‘checked’);
});

btn.addEventListener(‘click’, ({ target }) => {
	const { classList } = target;
	classList.toggle(‘checked’);
});
```

특히 파라미터 부분에서 객체를 분해하는 방식은 많이 사용!!

#### 퀴즈

함수명(‘이름값’, 객체명);

1. function 함수명(이름, 객체명) {
   1. console.log( `${이름}, ${객체명.속성명1}, ${객체명.속성명2}`); }
2. function 함수명(이름, 객체명) {
   1. const { 속성명1, 속성명2 } = 객체명;
   2. console.log(`${이름}, ${속성명1}, ${속성명2}`); }
3. function 함수명(이름, { 속성명1, 속성명2 }) {
   1. console.log(`${이름}, ${속성명1}, ${속성명2}`); }

### 에러 핸들링, 예외 처리, Exception Handling

에러 객체 종류 2. ReferenceError: 존재하지 않는 변수나 함수 호출시 발생 3. TypeError: 잘못된 방식으로 자료형 조작시 발생 4. SyntaxError: 잘못된 문법으로 코드 작성시 발생 1. 실행도 전에 에러 반환

에러 객체 프로퍼티

- name
- message

에러 객체 만들기

```
const error = new TypeError(‘타입 에러 발생’);
// error.name은 TypeError
// error.message는 ‘타입 에러 발생’
```

근데 에러 발생된건 아님

의도적으로 에러 발생시키기
throw new TypeError(‘에러문구’);
// 그럼 실제로 내가 만든 에러가 에러문으로 반환
//이후에 동작도 안함

try {} catch(err) {}
try문에서 코드 실행중 에러가 나면 catch문 실행
try문 내 에러 이후 코드는 실행 안함
에러문도 출력하지 않음!
console.error(err); 는 실제 에러문 형식으로 출력

```
function 함수명() {
	try {
		에러가 발생할거같은 코드~
	} catch (err) {
		console.error(err);
	}
}
이후 코드들은 코드 제대로 실행됨
```

주의!

- try catch문도 블록문이기 때문에 지역변수는 다른 블록에서 사용 XX
- SyntaxError에겐 소용XX => 코드 실행 조차 안됨

try {} catch(err) {} finally {}

- finally는 에러 여부와 상관 없이 항상 실행
- finally 문에서 에러처리가 필요한 경우, try catch문 중첩해서 활용

```
try {
  try {
    // 실행할 코드
  } catch (err) {
    // 에러가 발생했을 때 실행할 코드
  } finally {
    // 항상 실행할 코드
  }
} catch (err) {
  // finally문에서 에러가 발생했을 때 실행할 코드
}
```

finally에서 에러가 또 발생하면

- 마저 실행하고 바깥으로 에러 전파 (이전 에러 덮어쓰기됨)

* 기존 에러는 무시되고, finally의 에러가 새로 전파됨
* 이 에러는 바깥 try 블록이 있으면 거기 catch에서 잡힘

## JS 내부기능

### .forEach()

```
for (요소 of 배열명) { }
배열.forEach((요소, 인덱스, 배열) => { });
```

인자값으로 콜백함수 전달 시

- 첫번째 파라미터로 배열 요소를 하나씩 전달
  => 콜백 함수에 파라미터 꼭 있어야함
- 두번째 파라미터로 인덱스 관리!
  => 다른 배열과 함께 사용시 같은 인덱스 요소 매칭에 응용 가능
- 세번째 파라미터로 반복중인 배열 자체 전달
  => 변수명 없는 배열에 forEach 사용시 배열 자체 참조할 때 사용 가능

### .map()

```
for (요소 of 배열명) { }
배열.map((요소, 인덱스, 배열) => { return 반환문; });
배열.map((요소, 인덱스, 배열) => 반환문;);
```

호출 결과로 새로운 배열 반환 (return문이 없어도)
forEach는 리턴값 없음! 못씀! 안됨! 변수에 담으면 항상 undefined

=> 배열의 단순 반복 작업에는 forEach
=> 새 배열이 필요할 경우에는 map

++ 참고! in forEach / map
최대 반복 횟수? 그당시 요소의 개수
push로 값을 넣어도 당시 요소 개수만큼 반복 동작 (추가된 값은 무시)
근데 push도 실행되긴 함!
++ 예외!
근데 pop으로 값을 빼면 반복 실행 횟수도 줄어듦!! (값이 없으니까)

### .filter()

const 변수명 = 배열.filter((요소) => 조건식);
조건에 해당하는 요소만 해당하는 배열로 반환
하나만 있어도 요소 하나 있는 배열로 리턴
=> spread 문법으로 배열 벗겨야함

### .find()

하나의 값만 반환받고 싶을 때 사용
해당되는 값이 많아도 제일 처음 검색된 값만 반환 (함수 실행도 종료)
해당되는 값이 없으면 undefined 반환

# 강의 - 비동기 JS

async는 함수 선언
await은 함수 실행

const response = await fetch(‘https:…’);
// fetch는 비동기 함수라 promise 반환
// 결과가 아니라 약속만 오고 내부 데이터는 나중에 도착
// await는 promise가 끝날때까지 기다린 후 그 결과값을 변수에 할당시키는 연산자
const data = await response.json();
//.json()도 비동기 함수!
// json 형태의 문자열 데이터를 json 객체로 파싱하는 과정이 필요
console.log(data);

함수 할당할 때도 await 필요!
실행만하고 나와버리기 때문! await이 따로 달려가서 값 넣어줘야함ㅋㅋ

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 조금 남은게 아쉽다.. 그래도 내일 오전에 다 하기
- 아쉬운거 없다. 실무에서 자주 쓰는 연산자랑 함수 사용하기 시작하니까 익숙해서 즐겁다!!

---

## 🚀 내일의 계획

- 모던JS 끝내기
- 스프린트 1,2 피드백이랑 모범답안 반영해서 수정하기

---
