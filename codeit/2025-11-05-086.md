# 🗓️ 20yy-mm-dd TIL n일차

## ✅ 오늘의 진행 (완료한 작업)

- \[오늘 한 작업 요약]

---

## 🛠️ 작업 상세

### 🔹 구현/수정한 기능

- 예

### 🔹 발생한 이슈 & 해결 과정

- 예

### 🔹 미해결/보류된 이슈

- 예

---

## 📓 작업 메모 (코드/아이디어/레퍼런스)

<details>
<summary style="font-size: 22px;">📝 메모장</summary>

### 1️⃣ 데이터 구조 재정리

- **Photocards**: 카드 종류 단위 (예: “BTS RM 카드”)
- **UserPhotocards**: 실제 각 사용자가 소유한 카드, 수량 1개 단위
- **TradePosts**: 거래 글, 하나의 카드 종류를 판매용으로 묶음 → 여러 UserPhotocards를 참조

즉, **TradePosts는 “판매용 카드 종류” 단위**, **UserPhotocards는 실제 소유 카드 단위**입니다.

---

### 2️⃣ TradePosts → UserPhotocards 연결

- TradePosts에는 `UserPhotocards[]`가 관계로 연결되어 있음 (`trade_info_id`)
- 하나의 TradePost는 여러 UserPhotocards를 가리킬 수 있음

  - 예: 3명이 각 1개씩 소유한 카드 → TradePost에서 총 3개 카드 판매 가능

```ts
tradePost.userPhotocards; // [{id:1, is_sale:true}, {id:2, is_sale:true}, {id:3, is_sale:false}]
```

- 판매 가능 수량 = `userPhotocards.filter(c => !c.is_sale).length`
- 품절 여부 = `userPhotocards.some(c => c.is_sale === false) ? false : true`

---

### 3️⃣ 정리: “한 카드 종류 단위” 조회

1. TradePosts를 조회
2. 각 TradePost에 연결된 UserPhotocards를 함께 가져옴 (`include`)
3. UserPhotocards에서 판매 가능 수량 계산
4. 필요한 경우 `isSoldOut` 필터 적용

즉, **TradePost가 단위**, UserPhotocards는 **판매 가능한 실제 카드 수량 단위**라고 생각하면 됩니다.

---

💡 핵심 포인트

- TradePosts는 카드 종류 단위 → 반환 단위
- UserPhotocards는 실제 소유 단위 → 수량/판매 여부 계산용
- 한 번의 쿼리에서 `include` + `none/some` 활용하면 **N+1 없이 품절 여부** 계산 가능

---

## 1️⃣ 데이터 구조 가정

- **TradePosts** (id, trade_note, …)
- **UserPhotocards** (id, trade_info_id, is_sale)

예시 데이터:

| TradePost.id | UserPhotocards.is_sale |
| ------------ | ---------------------- |
| 1            | true                   |
| 1            | false                  |
| 2            | true                   |
| 3            | false                  |
| 3            | false                  |

---

## 2️⃣ none / some 의미

- **`none: { is_sale: true }`** → TradePost에 연결된 UserPhotocards 중 **is_sale = true가 하나도 없는 것만 남김**
- **`some: { is_sale: true }`** → TradePost에 연결된 UserPhotocards 중 **is_sale = true인 카드가 하나라도 있으면 남김**

즉, TradePost **row 단위로 판단**하는 조건입니다.

---

## 3️⃣ 내부 동작 (SQL 느낌으로)

```sql
SELECT *
FROM TradePosts t
WHERE NOT EXISTS (
  SELECT 1
  FROM UserPhotocards u
  WHERE u.trade_info_id = t.id
    AND u.is_sale = true
)
```

- `none: { is_sale: true }` → `NOT EXISTS`
- `some: { is_sale: true }` → `EXISTS`
- Prisma 내부에서 join + exists/subquery를 만들어서 **TradePosts를 남길지 버릴지 결정**

---

## 4️⃣ 결과가 어떻게 되는지

### a) none: { is_sale: true } 적용

- TradePost 1 → userPhotocards: [true, false] → 하나라도 true 있음 → **제외**
- TradePost 2 → [true] → true 있음 → **제외**
- TradePost 3 → [false, false] → true 없음 → **남김**

결과: TradePost 3만 반환

### b) some: { is_sale: true } 적용

- TradePost 1 → [true, false] → true 있음 → **남김**
- TradePost 2 → [true] → true 있음 → **남김**
- TradePost 3 → [false, false] → true 없음 → **제외**

결과: TradePost 1, 2만 반환

---

## 5️⃣ 핵심 이해 포인트

1. **none/some은 boolean을 반환하는 게 아니라, TradePost row를 “남길지 버릴지” 필터링**
2. **실제 UserPhotocards 데이터는 가져오지 않음** → 필요하면 `include`로 가져와야 함
3. 내부적으로는 **JOIN + EXISTS / NOT EXISTS** 로 조건 검사

---

즉 MJ가 헷갈렸던 부분:

> “none: { is_sale: true }가 boolean 반환하면 userPhotocards:true/false 이런 식으로 오나?”

→ **아니에요. 반환되는 건 TradePost row 전체**이고, none/some은 **TradePost를 남길지 버릴지 결정하는 조건**일 뿐이에요.

---

## 💡 전체 개선 요약

| 구분                             | 개선 전                                                                        | 개선 후                                                                             | 효과                                               |
| -------------------------------- | ------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------- | -------------------------------------------------- |
| **1️⃣ 조회 기준 모델**            | `Photocards` 기준 조회                                                         | `UserPhotocards` 기준 조회                                                          | 실제 “유저가 가진 카드 목록”에 맞는 구조로 변경 ✅ |
| **2️⃣ 필터 조건(where)**          | `grade`, `genre`, `keyword`를 Photocards에 직접 걸 수 없음                     | 관계 접근(`photocard.grade`, `photocard.genre`, `photocard.name`)으로 정확한 필터링 | 필터 정확도 향상 ✅                                |
| **3️⃣ 판매 상태 필터**            | 없음 or 불명확 (`is_sale` 고려 X)                                              | `is_sale: true` 명시                                                                | 실제 “판매 중” 카드만 조회 ✅                      |
| **4️⃣ 등급별 개수 계산(groupBy)** | Prisma `groupBy` 사용, 하지만 관계 필드(`photocard.grade`)로 인해 작동 불가 ❌ | `findMany`로 join 후 JS에서 직접 카운트 계산                                        | 관계 필드 접근 가능 + Prisma 제약 회피 ✅          |
| **5️⃣ totalCount 계산**           | Photocards count                                                               | UserPhotocards count                                                                | 실제 유저 보유 카드 개수와 일치 ✅                 |
| **6️⃣ select 필드 구조**          | Photocards 중심 필드만 조회                                                    | `photocard` join 포함 → name, grade, genre, price 등 안전하게 포함                  | 정확한 데이터 구조 유지 ✅                         |
| **7️⃣ 리턴 포맷**                 | 단순 배열 반환                                                                 | `{ totalCount, grade, list }` 구조로 JSON 통일                                      | 프론트 요구 포맷에 완벽 대응 ✅                    |
| **8️⃣ 가독성 / 유지보수성**       | where, groupBy, select가 혼재되어 복잡                                         | 단계별(필터 → count → group → list → format)로 분리                                 | 훨씬 명료하고 수정 용이 ✅                         |

---

## 🧩 핵심 개선 포인트 3줄 요약

1. **쿼리 기준을 유저 보유 카드(UserPhotocards)로 변경 → 도메인 모델 정확도 향상**
2. **관계 필드(Photocards.grade, name 등) 접근 문제 해결 → groupBy 대신 JS 루프 활용**
3. **응답 구조를 프론트 JSON 포맷에 맞춤 → totalCount / grade / list 완벽 정렬**

---

## ⚙️ 개발자 관점 요약

> 이 코드는 단순 조회 함수에서 “비즈니스 요구사항 중심의 데이터 집계 서비스”로 진화한 버전이에요.
> Prisma의 제약(`groupBy`는 관계필드 불가)을 회피하면서,
> 정확한 필터링과 깔끔한 리턴 포맷까지 모두 보장한 **현실적인 최적화 버전**입니다. ✅

</details>

---

## 🧠 오늘의 회고 (아쉬움 & 배운 점)

- 예

---

## 🚀 내일의 계획

- 예
