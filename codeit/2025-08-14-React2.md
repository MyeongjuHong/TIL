# 🗓️ 2025-08-14 TIL

## ✅ 오늘의 성취 (잘한 점)

- 야호 끝끝 이제 한 챕터 남았당
- 화이팅...............

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

React에서 CRUD 처리와 상태(state) 관리, 폼 제출, 파일 업로드, Hook 활용 및 콜백 패턴 이해

### 🔹 주요 개념 정리

- **POST/PUT/DELETE**: 서버에 데이터를 생성, 수정, 삭제
- **FormData**: 파일 포함 전송 시 사용, `multipart/form-data`
- **상위-하위 상태 관리**: 폼은 입력만 담당, 리스트/상태는 부모 관리
- **콜백 함수**: `onSubmitSuccess`, `onUpdateSuccess`를 통해 하위 → 상위 데이터 전달
- **Hook**
  - `useState`: 컴포넌트 상태 관리
  - `useEffect`: 렌더링 후 SideEffect 처리 및 cleanup
  - `useRef`: DOM 접근, 렌더링간 동일 객체 참조
  - `useCallback`: 함수 메모이제이션, 불필요한 재렌더 방지
- **의존성 관리**: useEffect/useCallback의 의존성 배열에 최신 state/props 반영, 필요 없는 useCallback 남발 지양
- **커스텀 Hook**: 재사용 로직 추출, `use~` 네이밍 규칙

### 🔹 예제 코드

```jsx
// POST 요청
const formData = new FormData();
formData.append("title", values.title);
formData.append("rating", values.rating);
formData.append("content", values.content);
formData.append("imgFile", values.imgFile);
const { food } = await createFood(formData);
setValues(INITIAL_VALUES);
onSubmitSuccess(food);

// PUT 요청
const handleUpdate = async (id, formData) ={
  const updated = await updateReview(id, formData);
  onUpdateSuccess(updated);
};

// DELETE 요청
const handleDelete = async (id) ={
  await deleteReview(id);
  setItems((prev) =prev.filter((item) =item.id !== id));
};

// useEffect + cleanup
useEffect(() ={
  const timer = setInterval(() =console.log("tick"), 1000);
  return () =clearInterval(timer);
}, []);

// useCallback 예시
const handleClick = useCallback(() ={
  setCount((c) =c + 1);
}, []);
<Child onClick={handleClick} />;

// FileInput 초기 미리보기
const [preview, setPreview] = useState(initialPreview);
useEffect(() ={
  return () =setPreview(initialPreview);
}, [initialPreview]);
```

<details>
<summary style="font-size: 22px;">📓 메모장</summary>

# React 데이터 다루기

## 데이터 보내기

### POST

#### onSubmit 함수에 리뷰 생성 API 연동하기

파일(이진 데이터)을 전송해야 하므로, JSON이 아닌 `multipart/form-data` 형식을 사용

```javascript
const formData = new FormData();
formData.append("title", values.title);
formData.append("rating", values.rating);
formData.append("content", values.content);
formData.append("imgFile", values.imgFile);

await createReview(formData);
setValues(INITIAL_VALUES);
```

#### Response 데이터 반영

서버로부터 받은 새로운 데이터를 기존 상태에 추가

```javascript
onSubmitSuccess(item);
setItems((prevItems = [item, ...prevItems]));
```

#### handleSubmit() 함수에서 리퀘스트 보내기

`handleSubmit`을 `async` 함수로 변경하고, `await`을 사용하여 API 함수를 호출

```javascript
const handleSubmit = async (e) ={
  e.preventDefault();
  const formData = new FormData();
  formData.append("imgFile", values.imgFile);
  formData.append("title", values.title);
  formData.append("calorie", values.calorie);
  formData.append("content", values.content);
  await createFood(formData);
};
```

#### Response 값을 State에 반영하기

1.  **`FoodForm` 컴포넌트**: `onSubmitSuccess` prop을 추가하고, API 호출 성공 시 부모로부터 받은 이 함수를 실행 폼의 상태는 `INITIAL_VALUES`로 초기화

    ```javascript
    const INITIAL_VALUES = {
      imgFile: null,
      title: "",
      calorie: 0,
      content: "",
    };

    function FoodForm({ onSubmitSuccess }) {
      const [values, setValues] = useState(INITIAL_VALUES);

      const handleSubmit = async (e) ={
        e.preventDefault();
        const formData = new FormData();
        formData.append("imgFile", values.imgFile);
        formData.append("title", values.title);
        formData.append("calorie", values.calorie);
        formData.append("content", values.content);

        // API 호출 후 반환된 food 객체
        const { food } = await createFood(formData);

        setValues(INITIAL_VALUES); // 입력 폼 초기화
        onSubmitSuccess(food); // 부모 컴포넌트에 새로운 데이터 전달
      };
      // ...
    }
    ```

2.  **`App` 컴포넌트 (부모)**: `handleSubmitSuccess` 함수를 정의하여 `FoodForm`에 prop으로 전달 이 함수는 자식으로부터 받은 `newItem`을 `items` 상태 배열의 맨 앞에 추가

    ```javascript
    function App() {
      const [items, setItems] = useState([]);

      const handleSubmitSuccess = (newItem) ={
        setItems((prevItems) =[newItem, ...prevItems]);
      };

      return <FoodForm onSubmitSuccess={handleSubmitSuccess} />;
    }
    ```

#### 🤔 왜 Props와 콜백 함수로 데이터를 주고받을까?

>

- **상태 관리의 주체**: `FoodForm`은 새로운 음식을 '입력'하는 역할만 담당 실제 데이터 목록(`items`)은 리스트를 보여주는 부모 컴포넌트(`App`)가 관리해야
- **단방향 데이터 흐름**: React에서는 부모가 자식에게 **props**를 통해 데이터를 전달할 수 있지만, 자식이 부모의 **state**를 직접 수정할 수는 없음
- **콜백 함수 활용**: 자식은 `onSubmitSuccess`와 같은 콜백 함수를 호출하여 "데이터 생성이 완료되었으니 처리해달라"고 부모에게 알립니다. 새로운 데이터(`food`)는 이 함수의 인자로 전달됨
  - **부모 → 자식**: Props 전달 (데이터나 함수)
  - **자식 → 부모**: 콜백 함수 호출 (새로운 데이터를 인자로 전달)

---

### PUT

#### 수정 시 데이터 가져오기

1.  **수정 상태 관리**: `ReviewList` 컴포넌트에서 수정 중인 아이템의 `id`를 기억할 `editingId` 상태를 생성

    ```javascript
    const [editingId, setEditingId] = useState(null);
    ```

2.  **조건부 렌더링**: `item.id`가 `editingId`와 일치할 때만 일반 아이템 대신 `<ReviewForm />`을 렌더링

3.  **수정 모드 진입**: '수정' 버튼 클릭 시 `onEdit` prop으로 받은 `setEditingId` 함수를 호출하여 `editingId` 상태를 현재 아이템의 `id`로 설정

    ```javascript
    // ReviewListItem.js
    const handleEditClick = () ={
      onEdit(item.id); // onEdit은 setEditingId를 가리킴
    };
    ```

4.  **폼에 기존 데이터 채우기**: `ReviewForm`에 `initialValues`와 `initialPreview` prop을 추가하여 수정할 데이터를 미리 채워 넣음 '취소' 버튼을 위해 `onCancel` prop도 추가

    ```javascript
    // ReviewList.js
    const handleCancel = () =setEditingId(null);

    // ... map 안에서 ...
    {
      editingId === item.id ? (
        <ReviewForm
          initialValues={item}
          initialPreview={item.imgUrl}
          onCancel={handleCancel}
        />
      ) : (
        <ReviewListItem item={item} onEdit={setEditingId} />
      );
    }
    ```

5.  **이미지 미리보기 처리**: `FileInput` 컴포넌트에서 `initialPreview`를 받아 `preview` 상태의 초기값으로 사용 사용자가 파일을 선택하지 않거나 선택을 취소하면 `initialPreview` 이미지가 다시 보이도록 `useEffect`를 설정

    ```javascript
    // FileInput.js
    const [preview, setPreview] = useState(initialPreview);

    useEffect(() ={
      // 컴포넌트가 언마운트되거나, value 또는 initialPreview가 바뀔 때 preview를 초기화
      return () ={
        setPreview(initialPreview);
      };
    }, [value, initialPreview]);
    ```

#### 리뷰 수정 API 연동

`ReviewForm`은 데이터 생성(POST)과 수정(PUT)을 모두 처리할 수 있도록, 실제 API 호출 함수를 `onSubmit` prop으로 받음

#### 📝 구조 요약

>

- **최상위 (App.js)**
  - 전체 상태(`items`)를 관리
  - `createReview`, `updateReview` 같은 실제 API 호출 함수를 정의
  - API 호출 성공 시 상태를 업데이트할 `handleCreateSuccess`, `handleUpdateSuccess` 콜백 함수를 관리
- **중간 (ReviewList.js)**
  - 각 아이템을 렌더링하고, 수정 중인 아이템(`editingId`)을 관리
  - `App`에서 받은 `updateReview` 함수에 `id`를 바인딩하여 `ReviewForm`에 `onSubmit` prop으로 전달하는 **래퍼(wrapper) 함수**를 생성
- **하위 (ReviewForm.js)**
  - 실제 입력 폼 UI와 제출 로직을 담당
  - 어떤 API가 호출되는지는 신경 쓰지 않고, 오직 `onSubmit`과 `onSubmitSuccess` prop을 호출하는 역할만
    > **핵심**: 콜백 함수가 **하위 → 중간 → 상위** 순서로 호출되면서 최상위 컴포넌트의 상태(`items`)가 변경됨

#### 🔄 이 로직의 콜백 함수 흐름 (수정)

>

1.  **`App.js`**:
    >
        - `updateFood` API 함수와 `handleUpdateSuccess` 상태 업데이트 함수를 선언
        - `<FoodList onUpdate={updateFood} onUpdateSuccess={handleUpdateSuccess} />` 형태로 props를 전달
    >
2.  **`FoodList.js`**:

    >

        - `App`으로부터 `onUpdate`, `onUpdateSuccess` props를 받음
        - `FoodForm`에 전달할 `handleSubmit`과 `handleSubmitSuccess` 함수를 새로 정의

    >

        <!-- end list -->

        ```javascript
        // item.id를 미리 바인딩하여 onUpdate 함수를 호출
        const handleSubmit = (formData) =onUpdate(item.id, formData);
        ```

```
// 부모의 상태 업데이트 함수를 호출하고, 자신의 수정 모드를 종료
const handleSubmitSuccess = (newItem) ={
    onUpdateSuccess(newItem);
    setEditingId(null);
};
```

````
// ...
<FoodForm onSubmit={handleSubmit} onSubmitSuccess={handleSubmitSuccess} />
```
````

> 3.  **`FoodForm.js`**:

    - `onSubmit` prop으로 받은 `handleSubmit` 함수를 실행 API 호출은 여기서 직접 일어나지 않음

---

### DELETE

1.  **API 함수 선언**: `api.js`에 `delete` 요청을 보내는 함수를 생성

2.  **상태 업데이트**: 삭제 성공 시, `filter` 메서드를 사용하여 상태 배열에서 해당 `id`를 가진 아이템을 제외한 새로운 배열을 생성

3.  **함수형 업데이트**: 비동기 함수 호출 후 상태를 업데이트할 때는 **함수형 업데이트 패턴**을 사용하는 것이 안전 이는 항상 최신 상태(`prevItems`)를 기반으로 업데이트하는 것을 보장

    ```javascript
    const handleDelete = async (id) ={
      await deleteFood(id);
      setItems((prevItems) =prevItems.filter((item) =item.id !== id));
    };
    ```

---

## Hook

리액트 훅(`use~`)은 내가 작성한 코드를 리액트의 기능(상태 관리, 생명주기 등)에 **연결**하는 방법입니다.

- `useState`: 리액트가 관리하는 \*\*상태(state)\*\*에 변수를 연결
- `useEffect`: 내가 작성한 함수를 리액트의 **렌더링 주기**에 연결하여, 렌더링 이후에 실행되도록
- `useRef`: 리렌더링 되어도 동일한 객체 참조를 유지하는 값을 리액트에 연결

### 규칙

1.  **최상위에서만 호출**: 리액트 컴포넌트 함수나 커스텀 Hook 함수의 최상위 스코프에서만 호출해야
2.  **조건문/반복문 불가**: 반복문, 조건문, 중첩 함수 내에서 Hook을 실행하면 안 됨
3.  **일관된 호출 순서**: 리액트는 Hook이 호출되는 '순서'를 통해 각 Hook의 상태를 기억하기 때문에, 렌더링마다 항상 동일한 순서로 Hook이 호출되어야 함

### 커스텀 Hook

반복되는 로직을 `use`로 시작하는 함수로 분리하여 재사용할 수 있음 예를 들어, 여러 컴포넌트에서 동일한 폼 상태 관리 로직을 사용한다면 `useForm`과 같은 커스텀 Hook으로 만들 수 있음

### useCallback

`useEffect`의 의존성 배열에 함수를 넣을 때, 해당 함수가 렌더링마다 새로 생성되면 무한 루프가 발생할 수 있음 `useCallback`은 함수를 \*\*메모이제이션(기억)\*\*하여, 의존하는 값이 변경될 때만 함수를 재생성

**사용법**:

1.  기억하고 싶은 함수를 `useCallback`으로 감싸기
2.  두 번째 인자로 의존성 배열을 설정 (함수 내부에서 참조하는 외부 값)

<!-- end list -->

```javascript
const handleLoad = useCallback(async (options) ={
  // ...
  const { reviews } = await getReviews(options);
  setItems(reviews);
}, []); // 의존하는 외부 값이 없으므로 빈 배열
```

<details>
<summary>
✅ `useCallback`은 언제 꼭 필요할까?
</summary>

1.  **자식 컴포넌트에 함수를 props로 넘길 때**: 자식 컴포넌트가 `React.memo`로 최적화되어 있을 때, 부모가 렌더링될 때마다 새로운 함수 객체를 prop으로 넘기면 `React.memo`가 무용지물이 됨 `useCallback`으로 함수 참조를 고정하면 자식의 불필요한 리렌더링을 막을 수 있음
    >
2.  **`useEffect`의 의존성 배열에 함수를 넣어야 할 때**: 함수 자체가 변경될 때만 특정 effect를 실행하고 싶을 때 사용 하지만 이 경우, 가능하면 함수 자체보다는 함수가 의존하는 '값'을 의존성 배열에 넣는 것이 더 직관적입니다.
    > ⚠️ **그 외의 경우**: 무분별한 `useCallback` 사용은 오히려 코드를 복잡하게 만들고 성능 이점도 거의 없음 대부분의 경우 일반적인 함수 선언으로도 충분

#### 💡 파라미터를 활용해 `useCallback` 없이 의존성 문제 해결하기

> `useCallback`으로 함수를 감싸는 대신, 함수 로직을 `useEffect` 내부로 옮기거나 파라미터를 활용하여 의존성 문제를 피할 수 있음
>
> **❌ 함수 의존성 문제 예시**

```javascript
const [count, setCount] = useState(0);
```

// 이 함수는 렌더링마다 새로 생성됨
const increment = () =\setCount(c =\c + 1);

useEffect(() =\{
increment();
}, [increment]); // increment가 계속 바뀌므로 무한 루프 발생 가능성

**✅ 값 의존성으로 해결**

```javascript
const [count, setCount] = useState(0);
```

useEffect(() =\{
console.log("Count has changed\!");
// 필요한 로직을 effect 내에서 직접 처리
}, [count]); // 함수가 아닌 '값'에 의존

> **핵심**: 의존성 배열에는 함수 자체보다, 그 함수가 의존하는 **상태나 값**을 직접 넣는 것이 더 명확하고 안전한 경우가 많음

</details>
</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 어우 리액트 너무 어렵다.. 제대로 공부하려니까 더 어렵다
- 이해하는데 너무 오래 걸려서 그냥 실습도 따라하면서 배웠다ㅠㅠ

---

## 🚀 내일의 계획

- CS 스터디 공부!
- 나머지 영상 하나끝내기
- 새로운 챕터 나가기~~

---
