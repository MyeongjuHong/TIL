# 🗓️ 2025-09-23 TIL 61일차

## ✅ 오늘의 성취 (잘한 점)

- 예
- 예

---

## 📚 오늘의 학습 (배운 점)

### 🔹 핵심 주제

### 🔹 주요 개념 정리

### 🔹 예제 코드

<details>
<summary style="font-size: 22px;">📓 메모장</summary>
Q1. provider 우선순위
=> 종속성 있는걸 제외하고는 상관 ㄴㄴ

Q2. useQuery가 훅이면 use client를 쓰던데, 나는 그럼 기본 fetch 하는 곳에서 모두 use client를 쓰니까 next.js의 효율성에 어긋나지 않나?
=> ㅇㅇ 최대한 use client를 하위에 두는게 좋음. 하지만 애초에 next 자체가 렌더링을 page 단위로 쪼개서 렌더링되기 때문에 next를 쓰는 것 자체만으로도 리액트보다 효율적임. 그리고 next 인사이트를 위해서는 hydration 이해 필수!

```jsx
/* Tanstack Query Provider */

"use client";
// Next.js App Router(예: src/app)에서 이 파일을 '클라이언트 컴포넌트'로 취급하도록 하는 지시자입니다.
// 최상단에 있어야 하며, 브라우저 전용 훅(useState, useEffect 등)을 사용할 때 반드시 필요합니다.

import React, { useState } from "react";
// React는 최신 JSX 변환에서는 명시적 import가 없어도 동작하지만, 설명과 타입(예: React.ReactNode)을 위해 명시했습니다.
// useState 훅을 사용해서 QueryClient 인스턴스를 컴포넌트 생애주기 동안 유지합니다.

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
// QueryClient: React Query가 내부적으로 사용하는 '클라이언트' 인스턴스를 생성하는 생성자입니다.
// QueryClientProvider: React의 Context로 만들어 하위 컴포넌트들이 동일한 QueryClient에 접근하게 해주는 Provider 컴포넌트입니다.

import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
// 개발 편의용 도구입니다. 브라우저에서 React Query 캐시/쿼리 상태를 시각적으로 확인할 수 있게 해줍니다.
// 프로덕션 빌드에서는 포함하지 않거나, NODE_ENV 검사로 개발 환경에서만 렌더링하는 것이 권장됩니다.

export default function Providers({ children }) {
  // 이 컴포넌트는 '앱 전체(또는 일부)를 감싸는 Provider' 역할을 합니다.
  // children: React에서 컴포넌트의 자식 요소들을 가리키는 특별한 prop입니다.
  // (TypeScript 사용 시: function Providers({ children }: { children: React.ReactNode }) { ... } 처럼 타입 지정 가능)

  const [queryClient] = useState(() => new QueryClient());
  // useState에 lazy initializer(함수)를 전달하여 QueryClient 인스턴스를 '한 번만' 생성합니다.
  // 이유:
  //  - 컴포넌트가 재렌더링될 때마다 새 QueryClient를 만들지 않도록 하기 위함입니다.
  //  - QueryClient는 상태(캐시 등)를 내부에 가지고 있으므로 한 인스턴스를 앱 전체에서 재사용해야 합니다.
  // 비고:
  //  - setQueryClient(두 번째 요소)는 사용하지 않으므로 구조분해 할당으로 discard 했습니다.
  //  - 대안으로 useRef(() => new QueryClient()).current 방식도 있습니다.

  return (
    // QueryClientProvider로 감싼 하위 컴포넌트들은 useQuery/useMutation 같은 훅을 통해
    // 동일한 QueryClient(캐시, 설정 등)에 접근할 수 있게 됩니다.
    <QueryClientProvider client={queryClient}>
      {/* ReactQueryDevtools: 개발 시 디버깅에 유용한 UI를 표시합니다.
          - initialIsOpen={false}: 도구 창을 처음에는 닫힌 상태로 시작하도록 설정.
          - 주의: 번들 크기(특히 프로덕션) 영향을 막기 위해 보통은 개발 환경에서만 렌더링합니다.
            예: {process.env.NODE_ENV === "development" && <ReactQueryDevtools initialIsOpen={false} />}
      */}
      <ReactQueryDevtools initialIsOpen={false} />
      {/* children을 렌더링하여 이 Provider로 감싼 모든 컴포넌트가 QueryClient에 접근할 수 있게 합니다. */}
      {children}
    </QueryClientProvider>
  );
}
```

```jsx
/* Context Provider */

"use client";
// Next.js App Router에서 브라우저 전용 기능(useState 등)을 사용하려면 필요합니다.

import React, { createContext, useContext, useState } from "react";

// 1. Context 객체 생성
// createContext를 호출하면 전역적으로 상태를 공유할 수 있는 Context가 만들어집니다.
// 기본값(null)은 Provider로 감싸지 않았을 때 useContext가 반환하는 값입니다.
const ThemeContext = createContext(null);

// 2. Provider 컴포넌트 정의
// 이 컴포넌트는 내부적으로 useState를 써서 상태를 관리하고,
// 하위 children 컴포넌트에게 value를 전달합니다.
export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");
  // 전역으로 공유할 상태: 테마(light/dark)

  return (
    // Context.Provider로 감싸고 value prop에 공유할 상태/함수를 전달
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// 3. Context를 쉽게 사용할 수 있게 도와주는 custom hook
// 매번 useContext(ThemeContext) 쓰기 귀찮으니까 이렇게 함수로 감싸는 경우가 많습니다.
export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
}
```
#### 내부 로직에서 react query를 쓸 일이 있기 때문에 (like useQuery로 사용자 프로필 가져오기) react query provider 안에 들어가는게 좋음

```jsx
// 1️⃣ queryClient 가져오기
// useQueryClient 훅을 통해 React Query의 전역 캐시에 접근할 수 있는 클라이언트 객체를 가져옴
// 이 객체를 통해 캐시 조회, 무효화, 업데이트 등이 가능
const queryClient = useQueryClient();


// 2️⃣ useMutation 설정
const postTodoMutation = useMutation({
	// mutationFn: 실제 서버에 데이터를 추가하거나 변경하는 함수
	// 여기서는 새로운 Todo 항목을 서버나 API에 POST 요청하는 함수
	mutationFn: postTodo,

	// onSuccess: mutation이 성공적으로 완료되었을 때 실행되는 콜백
	onSuccess: () => {
		// 3️⃣ 캐시 무효화(invalidate)
		// ['todos']라는 queryKey를 가진 쿼리의 캐시를 무효화
		// 무효화된 쿼리는 다음 렌더링에서 자동으로 refetch 수행
		queryClient.invalidateQueries({queryKey: ['todos']})
	}
})


// 4️⃣ 버튼 클릭 시 새로운 Todo 항목 추가
<button onClick={() => {
	// mutate 호출: mutationFn 실행 + 상태 관리
	// 여기서 전달하는 객체는 postTodo 함수의 인자로 넘어감
	postTodoMutation.mutate({
		id: Date.now(),            // 고유 id 생성
		title: 'Tanstack Query 공부' // 할 일 제목
	})
}}>
	투두 추가
</button>
```

</details>

---

## 🧠 오늘의 개선 (어렵거나 아쉬웠던 점)

- 예
- 예

---

## 🚀 내일의 계획

- 예
- 예

---
